{"code":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { stringLength } from '@firebase/util';\r\nimport { nameCompare } from './util';\r\n/** Maximum key depth. */\r\nconst MAX_PATH_DEPTH = 32;\r\n/** Maximum number of (UTF8) bytes in a Firebase path. */\r\nconst MAX_PATH_LENGTH_BYTES = 768;\r\n/**\r\n * An immutable object representing a parsed path.  It's immutable so that you\r\n * can pass them around to other functions without worrying about them changing\r\n * it.\r\n */\r\nexport class Path {\r\n    /**\r\n     * @param pathOrString - Path string to parse, or another path, or the raw\r\n     * tokens array\r\n     */\r\n    constructor(pathOrString, pieceNum) {\r\n        if (pieceNum === void 0) {\r\n            this.pieces_ = pathOrString.split('/');\r\n            // Remove empty pieces.\r\n            let copyTo = 0;\r\n            for (let i = 0; i < this.pieces_.length; i++) {\r\n                if (this.pieces_[i].length > 0) {\r\n                    this.pieces_[copyTo] = this.pieces_[i];\r\n                    copyTo++;\r\n                }\r\n            }\r\n            this.pieces_.length = copyTo;\r\n            this.pieceNum_ = 0;\r\n        }\r\n        else {\r\n            this.pieces_ = pathOrString;\r\n            this.pieceNum_ = pieceNum;\r\n        }\r\n    }\r\n    toString() {\r\n        let pathString = '';\r\n        for (let i = this.pieceNum_; i < this.pieces_.length; i++) {\r\n            if (this.pieces_[i] !== '') {\r\n                pathString += '/' + this.pieces_[i];\r\n            }\r\n        }\r\n        return pathString || '/';\r\n    }\r\n}\r\nexport function newEmptyPath() {\r\n    return new Path('');\r\n}\r\nexport function pathGetFront(path) {\r\n    if (path.pieceNum_ >= path.pieces_.length) {\r\n        return null;\r\n    }\r\n    return path.pieces_[path.pieceNum_];\r\n}\r\n/**\r\n * @returns The number of segments in this path\r\n */\r\nexport function pathGetLength(path) {\r\n    return path.pieces_.length - path.pieceNum_;\r\n}\r\nexport function pathPopFront(path) {\r\n    let pieceNum = path.pieceNum_;\r\n    if (pieceNum < path.pieces_.length) {\r\n        pieceNum++;\r\n    }\r\n    return new Path(path.pieces_, pieceNum);\r\n}\r\nexport function pathGetBack(path) {\r\n    if (path.pieceNum_ < path.pieces_.length) {\r\n        return path.pieces_[path.pieces_.length - 1];\r\n    }\r\n    return null;\r\n}\r\nexport function pathToUrlEncodedString(path) {\r\n    let pathString = '';\r\n    for (let i = path.pieceNum_; i < path.pieces_.length; i++) {\r\n        if (path.pieces_[i] !== '') {\r\n            pathString += '/' + encodeURIComponent(String(path.pieces_[i]));\r\n        }\r\n    }\r\n    return pathString || '/';\r\n}\r\n/**\r\n * Shallow copy of the parts of the path.\r\n *\r\n */\r\nexport function pathSlice(path, begin = 0) {\r\n    return path.pieces_.slice(path.pieceNum_ + begin);\r\n}\r\nexport function pathParent(path) {\r\n    if (path.pieceNum_ >= path.pieces_.length) {\r\n        return null;\r\n    }\r\n    const pieces = [];\r\n    for (let i = path.pieceNum_; i < path.pieces_.length - 1; i++) {\r\n        pieces.push(path.pieces_[i]);\r\n    }\r\n    return new Path(pieces, 0);\r\n}\r\nexport function pathChild(path, childPathObj) {\r\n    const pieces = [];\r\n    for (let i = path.pieceNum_; i < path.pieces_.length; i++) {\r\n        pieces.push(path.pieces_[i]);\r\n    }\r\n    if (childPathObj instanceof Path) {\r\n        for (let i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {\r\n            pieces.push(childPathObj.pieces_[i]);\r\n        }\r\n    }\r\n    else {\r\n        const childPieces = childPathObj.split('/');\r\n        for (let i = 0; i < childPieces.length; i++) {\r\n            if (childPieces[i].length > 0) {\r\n                pieces.push(childPieces[i]);\r\n            }\r\n        }\r\n    }\r\n    return new Path(pieces, 0);\r\n}\r\n/**\r\n * @returns True if there are no segments in this path\r\n */\r\nexport function pathIsEmpty(path) {\r\n    return path.pieceNum_ >= path.pieces_.length;\r\n}\r\n/**\r\n * @returns The path from outerPath to innerPath\r\n */\r\nexport function newRelativePath(outerPath, innerPath) {\r\n    const outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);\r\n    if (outer === null) {\r\n        return innerPath;\r\n    }\r\n    else if (outer === inner) {\r\n        return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));\r\n    }\r\n    else {\r\n        throw new Error('INTERNAL ERROR: innerPath (' +\r\n            innerPath +\r\n            ') is not within ' +\r\n            'outerPath (' +\r\n            outerPath +\r\n            ')');\r\n    }\r\n}\r\n/**\r\n * @returns -1, 0, 1 if left is less, equal, or greater than the right.\r\n */\r\nexport function pathCompare(left, right) {\r\n    const leftKeys = pathSlice(left, 0);\r\n    const rightKeys = pathSlice(right, 0);\r\n    for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {\r\n        const cmp = nameCompare(leftKeys[i], rightKeys[i]);\r\n        if (cmp !== 0) {\r\n            return cmp;\r\n        }\r\n    }\r\n    if (leftKeys.length === rightKeys.length) {\r\n        return 0;\r\n    }\r\n    return leftKeys.length < rightKeys.length ? -1 : 1;\r\n}\r\n/**\r\n * @returns true if paths are the same.\r\n */\r\nexport function pathEquals(path, other) {\r\n    if (pathGetLength(path) !== pathGetLength(other)) {\r\n        return false;\r\n    }\r\n    for (let i = path.pieceNum_, j = other.pieceNum_; i <= path.pieces_.length; i++, j++) {\r\n        if (path.pieces_[i] !== other.pieces_[j]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * @returns True if this path is a parent of (or the same as) other\r\n */\r\nexport function pathContains(path, other) {\r\n    let i = path.pieceNum_;\r\n    let j = other.pieceNum_;\r\n    if (pathGetLength(path) > pathGetLength(other)) {\r\n        return false;\r\n    }\r\n    while (i < path.pieces_.length) {\r\n        if (path.pieces_[i] !== other.pieces_[j]) {\r\n            return false;\r\n        }\r\n        ++i;\r\n        ++j;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Dynamic (mutable) path used to count path lengths.\r\n *\r\n * This class is used to efficiently check paths for valid\r\n * length (in UTF8 bytes) and depth (used in path validation).\r\n *\r\n * Throws Error exception if path is ever invalid.\r\n *\r\n * The definition of a path always begins with '/'.\r\n */\r\nexport class ValidationPath {\r\n    /**\r\n     * @param path - Initial Path.\r\n     * @param errorPrefix_ - Prefix for any error messages.\r\n     */\r\n    constructor(path, errorPrefix_) {\r\n        this.errorPrefix_ = errorPrefix_;\r\n        this.parts_ = pathSlice(path, 0);\r\n        /** Initialize to number of '/' chars needed in path. */\r\n        this.byteLength_ = Math.max(1, this.parts_.length);\r\n        for (let i = 0; i < this.parts_.length; i++) {\r\n            this.byteLength_ += stringLength(this.parts_[i]);\r\n        }\r\n        validationPathCheckValid(this);\r\n    }\r\n}\r\nexport function validationPathPush(validationPath, child) {\r\n    // Count the needed '/'\r\n    if (validationPath.parts_.length > 0) {\r\n        validationPath.byteLength_ += 1;\r\n    }\r\n    validationPath.parts_.push(child);\r\n    validationPath.byteLength_ += stringLength(child);\r\n    validationPathCheckValid(validationPath);\r\n}\r\nexport function validationPathPop(validationPath) {\r\n    const last = validationPath.parts_.pop();\r\n    validationPath.byteLength_ -= stringLength(last);\r\n    // Un-count the previous '/'\r\n    if (validationPath.parts_.length > 0) {\r\n        validationPath.byteLength_ -= 1;\r\n    }\r\n}\r\nfunction validationPathCheckValid(validationPath) {\r\n    if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {\r\n        throw new Error(validationPath.errorPrefix_ +\r\n            'has a key path longer than ' +\r\n            MAX_PATH_LENGTH_BYTES +\r\n            ' bytes (' +\r\n            validationPath.byteLength_ +\r\n            ').');\r\n    }\r\n    if (validationPath.parts_.length > MAX_PATH_DEPTH) {\r\n        throw new Error(validationPath.errorPrefix_ +\r\n            'path specified exceeds the maximum depth that can be written (' +\r\n            MAX_PATH_DEPTH +\r\n            ') or object contains a cycle ' +\r\n            validationPathToErrorString(validationPath));\r\n    }\r\n}\r\n/**\r\n * String for use in error messages - uses '.' notation for path.\r\n */\r\nexport function validationPathToErrorString(validationPath) {\r\n    if (validationPath.parts_.length === 0) {\r\n        return '';\r\n    }\r\n    return \"in property '\" + validationPath.parts_.join('.') + \"'\";\r\n}\r\n//# sourceMappingURL=Path.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/util/dist/index.d.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/util.ts"],"map":"{\"version\":3,\"file\":\"Path.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/core/util/Path.ts\"],\"names\":[],\"mappings\":\"AAAA;;;;;;;;;;;;;;;GAeG;AAEH,OAAO,EAAE,YAAY,EAAE,MAAM,gBAAgB,CAAC;AAE9C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAErC,yBAAyB;AACzB,MAAM,cAAc,GAAG,EAAE,CAAC;AAE1B,yDAAyD;AACzD,MAAM,qBAAqB,GAAG,GAAG,CAAC;AAElC;;;;GAIG;AAEH,MAAM,OAAO,IAAI;IAIf;;;OAGG;IACH,YAAY,YAA+B,EAAE,QAAiB;QAC5D,IAAI,QAAQ,KAAK,KAAK,CAAC,EAAE;YACvB,IAAI,CAAC,OAAO,GAAI,YAAuB,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YAEnD,uBAAuB;YACvB,IAAI,MAAM,GAAG,CAAC,CAAC;YACf,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC5C,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;oBAC9B,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oBACvC,MAAM,EAAE,CAAC;iBACV;aACF;YACD,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,MAAM,CAAC;YAE7B,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;SACpB;aAAM;YACL,IAAI,CAAC,OAAO,GAAG,YAAwB,CAAC;YACxC,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;SAC3B;IACH,CAAC;IAED,QAAQ;QACN,IAAI,UAAU,GAAG,EAAE,CAAC;QACpB,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACzD,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;gBAC1B,UAAU,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;aACrC;SACF;QAED,OAAO,UAAU,IAAI,GAAG,CAAC;IAC3B,CAAC;CACF;AAED,MAAM,UAAU,YAAY;IAC1B,OAAO,IAAI,IAAI,CAAC,EAAE,CAAC,CAAC;AACtB,CAAC;AAED,MAAM,UAAU,YAAY,CAAC,IAAU;IACrC,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;QACzC,OAAO,IAAI,CAAC;KACb;IAED,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AACtC,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,aAAa,CAAC,IAAU;IACtC,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC;AAC9C,CAAC;AAED,MAAM,UAAU,YAAY,CAAC,IAAU;IACrC,IAAI,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC;IAC9B,IAAI,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;QAClC,QAAQ,EAAE,CAAC;KACZ;IACD,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;AAC1C,CAAC;AAED,MAAM,UAAU,WAAW,CAAC,IAAU;IACpC,IAAI,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;QACxC,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;KAC9C;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED,MAAM,UAAU,sBAAsB,CAAC,IAAU;IAC/C,IAAI,UAAU,GAAG,EAAE,CAAC;IACpB,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACzD,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;YAC1B,UAAU,IAAI,GAAG,GAAG,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SACjE;KACF;IAED,OAAO,UAAU,IAAI,GAAG,CAAC;AAC3B,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,SAAS,CAAC,IAAU,EAAE,QAAgB,CAAC;IACrD,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC,CAAC;AACpD,CAAC;AAED,MAAM,UAAU,UAAU,CAAC,IAAU;IACnC,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;QACzC,OAAO,IAAI,CAAC;KACb;IAED,MAAM,MAAM,GAAG,EAAE,CAAC;IAClB,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;QAC7D,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;KAC9B;IAED,OAAO,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;AAC7B,CAAC;AAED,MAAM,UAAU,SAAS,CAAC,IAAU,EAAE,YAA2B;IAC/D,MAAM,MAAM,GAAG,EAAE,CAAC;IAClB,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACzD,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;KAC9B;IAED,IAAI,YAAY,YAAY,IAAI,EAAE;QAChC,KAAK,IAAI,CAAC,GAAG,YAAY,CAAC,SAAS,EAAE,CAAC,GAAG,YAAY,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACzE,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;SACtC;KACF;SAAM;QACL,MAAM,WAAW,GAAG,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC5C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC3C,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC7B,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;aAC7B;SACF;KACF;IAED,OAAO,IAAI,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;AAC7B,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,WAAW,CAAC,IAAU;IACpC,OAAO,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;AAC/C,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,eAAe,CAAC,SAAe,EAAE,SAAe;IAC9D,MAAM,KAAK,GAAG,YAAY,CAAC,SAAS,CAAC,EACnC,KAAK,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC;IAClC,IAAI,KAAK,KAAK,IAAI,EAAE;QAClB,OAAO,SAAS,CAAC;KAClB;SAAM,IAAI,KAAK,KAAK,KAAK,EAAE;QAC1B,OAAO,eAAe,CAAC,YAAY,CAAC,SAAS,CAAC,EAAE,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC;KAC1E;SAAM;QACL,MAAM,IAAI,KAAK,CACb,6BAA6B;YAC3B,SAAS;YACT,kBAAkB;YAClB,aAAa;YACb,SAAS;YACT,GAAG,CACN,CAAC;KACH;AACH,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,WAAW,CAAC,IAAU,EAAE,KAAW;IACjD,MAAM,QAAQ,GAAG,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IACpC,MAAM,SAAS,GAAG,SAAS,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;IACtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,IAAI,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAChE,MAAM,GAAG,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;QACnD,IAAI,GAAG,KAAK,CAAC,EAAE;YACb,OAAO,GAAG,CAAC;SACZ;KACF;IACD,IAAI,QAAQ,CAAC,MAAM,KAAK,SAAS,CAAC,MAAM,EAAE;QACxC,OAAO,CAAC,CAAC;KACV;IACD,OAAO,QAAQ,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACrD,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,UAAU,CAAC,IAAU,EAAE,KAAW;IAChD,IAAI,aAAa,CAAC,IAAI,CAAC,KAAK,aAAa,CAAC,KAAK,CAAC,EAAE;QAChD,OAAO,KAAK,CAAC;KACd;IAED,KACE,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,EAAE,CAAC,GAAG,KAAK,CAAC,SAAS,EAC3C,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EACxB,CAAC,EAAE,EAAE,CAAC,EAAE,EACR;QACA,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;YACxC,OAAO,KAAK,CAAC;SACd;KACF;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,YAAY,CAAC,IAAU,EAAE,KAAW;IAClD,IAAI,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC;IACvB,IAAI,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC;IACxB,IAAI,aAAa,CAAC,IAAI,CAAC,GAAG,aAAa,CAAC,KAAK,CAAC,EAAE;QAC9C,OAAO,KAAK,CAAC;KACd;IACD,OAAO,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE;QAC9B,IAAI,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE;YACxC,OAAO,KAAK,CAAC;SACd;QACD,EAAE,CAAC,CAAC;QACJ,EAAE,CAAC,CAAC;KACL;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;;;;;GASG;AACH,MAAM,OAAO,cAAc;IAKzB;;;OAGG;IACH,YAAY,IAAU,EAAS,YAAoB;QAApB,iBAAY,GAAZ,YAAY,CAAQ;QACjD,IAAI,CAAC,MAAM,GAAG,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QACjC,wDAAwD;QACxD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;QAEnD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC3C,IAAI,CAAC,WAAW,IAAI,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;SAClD;QACD,wBAAwB,CAAC,IAAI,CAAC,CAAC;IACjC,CAAC;CACF;AAED,MAAM,UAAU,kBAAkB,CAChC,cAA8B,EAC9B,KAAa;IAEb,uBAAuB;IACvB,IAAI,cAAc,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;QACpC,cAAc,CAAC,WAAW,IAAI,CAAC,CAAC;KACjC;IACD,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IAClC,cAAc,CAAC,WAAW,IAAI,YAAY,CAAC,KAAK,CAAC,CAAC;IAClD,wBAAwB,CAAC,cAAc,CAAC,CAAC;AAC3C,CAAC;AAED,MAAM,UAAU,iBAAiB,CAAC,cAA8B;IAC9D,MAAM,IAAI,GAAG,cAAc,CAAC,MAAM,CAAC,GAAG,EAAE,CAAC;IACzC,cAAc,CAAC,WAAW,IAAI,YAAY,CAAC,IAAI,CAAC,CAAC;IACjD,4BAA4B;IAC5B,IAAI,cAAc,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;QACpC,cAAc,CAAC,WAAW,IAAI,CAAC,CAAC;KACjC;AACH,CAAC;AAED,SAAS,wBAAwB,CAAC,cAA8B;IAC9D,IAAI,cAAc,CAAC,WAAW,GAAG,qBAAqB,EAAE;QACtD,MAAM,IAAI,KAAK,CACb,cAAc,CAAC,YAAY;YACzB,6BAA6B;YAC7B,qBAAqB;YACrB,UAAU;YACV,cAAc,CAAC,WAAW;YAC1B,IAAI,CACP,CAAC;KACH;IACD,IAAI,cAAc,CAAC,MAAM,CAAC,MAAM,GAAG,cAAc,EAAE;QACjD,MAAM,IAAI,KAAK,CACb,cAAc,CAAC,YAAY;YACzB,gEAAgE;YAChE,cAAc;YACd,+BAA+B;YAC/B,2BAA2B,CAAC,cAAc,CAAC,CAC9C,CAAC;KACH;AACH,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,2BAA2B,CACzC,cAA8B;IAE9B,IAAI,cAAc,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;QACtC,OAAO,EAAE,CAAC;KACX;IACD,OAAO,eAAe,GAAG,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC;AACjE,CAAC\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/core/util/Path.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * An immutable object representing a parsed path.  It's immutable so that you\r\n * can pass them around to other functions without worrying about them changing\r\n * it.\r\n */\r\nexport declare class Path {\r\n    pieces_: string[];\r\n    pieceNum_: number;\r\n    /**\r\n     * @param pathOrString - Path string to parse, or another path, or the raw\r\n     * tokens array\r\n     */\r\n    constructor(pathOrString: string | string[], pieceNum?: number);\r\n    toString(): string;\r\n}\r\nexport declare function newEmptyPath(): Path;\r\nexport declare function pathGetFront(path: Path): string | null;\r\n/**\r\n * @returns The number of segments in this path\r\n */\r\nexport declare function pathGetLength(path: Path): number;\r\nexport declare function pathPopFront(path: Path): Path;\r\nexport declare function pathGetBack(path: Path): string | null;\r\nexport declare function pathToUrlEncodedString(path: Path): string;\r\n/**\r\n * Shallow copy of the parts of the path.\r\n *\r\n */\r\nexport declare function pathSlice(path: Path, begin?: number): string[];\r\nexport declare function pathParent(path: Path): Path | null;\r\nexport declare function pathChild(path: Path, childPathObj: string | Path): Path;\r\n/**\r\n * @returns True if there are no segments in this path\r\n */\r\nexport declare function pathIsEmpty(path: Path): boolean;\r\n/**\r\n * @returns The path from outerPath to innerPath\r\n */\r\nexport declare function newRelativePath(outerPath: Path, innerPath: Path): Path;\r\n/**\r\n * @returns -1, 0, 1 if left is less, equal, or greater than the right.\r\n */\r\nexport declare function pathCompare(left: Path, right: Path): number;\r\n/**\r\n * @returns true if paths are the same.\r\n */\r\nexport declare function pathEquals(path: Path, other: Path): boolean;\r\n/**\r\n * @returns True if this path is a parent of (or the same as) other\r\n */\r\nexport declare function pathContains(path: Path, other: Path): boolean;\r\n/**\r\n * Dynamic (mutable) path used to count path lengths.\r\n *\r\n * This class is used to efficiently check paths for valid\r\n * length (in UTF8 bytes) and depth (used in path validation).\r\n *\r\n * Throws Error exception if path is ever invalid.\r\n *\r\n * The definition of a path always begins with '/'.\r\n */\r\nexport declare class ValidationPath {\r\n    errorPrefix_: string;\r\n    parts_: string[];\r\n    /** Initialize to number of '/' chars needed in path. */\r\n    byteLength_: number;\r\n    /**\r\n     * @param path - Initial Path.\r\n     * @param errorPrefix_ - Prefix for any error messages.\r\n     */\r\n    constructor(path: Path, errorPrefix_: string);\r\n}\r\nexport declare function validationPathPush(validationPath: ValidationPath, child: string): void;\r\nexport declare function validationPathPop(validationPath: ValidationPath): void;\r\n/**\r\n * String for use in error messages - uses '.' notation for path.\r\n */\r\nexport declare function validationPathToErrorString(validationPath: ValidationPath): string;\r\n"}}
