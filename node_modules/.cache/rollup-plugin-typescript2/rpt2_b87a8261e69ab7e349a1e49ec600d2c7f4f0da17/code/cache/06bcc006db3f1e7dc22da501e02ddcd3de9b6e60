{"code":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { assert } from '@firebase/util';\r\nimport { AckUserWrite } from './operation/AckUserWrite';\r\nimport { ListenComplete } from './operation/ListenComplete';\r\nimport { Merge } from './operation/Merge';\r\nimport { newOperationSourceServer, newOperationSourceServerTaggedQuery, newOperationSourceUser } from './operation/Operation';\r\nimport { Overwrite } from './operation/Overwrite';\r\nimport { ChildrenNode } from './snap/ChildrenNode';\r\nimport { SyncPoint, syncPointAddEventRegistration, syncPointApplyOperation, syncPointGetCompleteServerCache, syncPointGetCompleteView, syncPointGetQueryViews, syncPointGetView, syncPointHasCompleteView, syncPointIsEmpty, syncPointRemoveEventRegistration, syncPointViewExistsForQuery, syncPointViewForQuery } from './SyncPoint';\r\nimport { ImmutableTree } from './util/ImmutableTree';\r\nimport { newEmptyPath, newRelativePath, Path, pathGetFront, pathIsEmpty } from './util/Path';\r\nimport { each, errorForServerCode } from './util/util';\r\nimport { CacheNode } from './view/CacheNode';\r\nimport { viewGetCompleteNode, viewGetServerCache } from './view/View';\r\nimport { newWriteTree, writeTreeAddMerge, writeTreeAddOverwrite, writeTreeCalcCompleteEventCache, writeTreeChildWrites, writeTreeGetWrite, writeTreeRefChild, writeTreeRemoveWrite } from './WriteTree';\r\nlet referenceConstructor;\r\nexport function syncTreeSetReferenceConstructor(val) {\r\n    assert(!referenceConstructor, '__referenceConstructor has already been defined');\r\n    referenceConstructor = val;\r\n}\r\nfunction syncTreeGetReferenceConstructor() {\r\n    assert(referenceConstructor, 'Reference.ts has not been loaded');\r\n    return referenceConstructor;\r\n}\r\n/**\r\n * Static tracker for next query tag.\r\n */\r\nlet syncTreeNextQueryTag_ = 1;\r\nexport function resetSyncTreeTag() {\r\n    syncTreeNextQueryTag_ = 1;\r\n}\r\n/**\r\n * SyncTree is the central class for managing event callback registration, data caching, views\r\n * (query processing), and event generation.  There are typically two SyncTree instances for\r\n * each Repo, one for the normal Firebase data, and one for the .info data.\r\n *\r\n * It has a number of responsibilities, including:\r\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\r\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\r\n *    (applyUserOverwrite(), applyUserMerge()).\r\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\r\n *    applyServerMerge()).\r\n *  - Generating user-facing events for server and user changes (all of the apply* methods\r\n *    return the set of events that need to be raised as a result).\r\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\r\n *    to the correct set of paths and queries to satisfy the current set of user event\r\n *    callbacks (listens are started/stopped using the provided listenProvider).\r\n *\r\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\r\n * events are returned to the caller rather than raised synchronously.\r\n *\r\n */\r\nexport class SyncTree {\r\n    /**\r\n     * @param listenProvider_ - Used by SyncTree to start / stop listening\r\n     *   to server data.\r\n     */\r\n    constructor(listenProvider_) {\r\n        this.listenProvider_ = listenProvider_;\r\n        /**\r\n         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\r\n         */\r\n        this.syncPointTree_ = new ImmutableTree(null);\r\n        /**\r\n         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\r\n         */\r\n        this.pendingWriteTree_ = newWriteTree();\r\n        this.tagToQueryMap = new Map();\r\n        this.queryToTagMap = new Map();\r\n    }\r\n}\r\n/**\r\n * Apply the data changes for a user-generated set() or transaction() call.\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport function syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {\r\n    // Record pending write.\r\n    writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);\r\n    if (!visible) {\r\n        return [];\r\n    }\r\n    else {\r\n        return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));\r\n    }\r\n}\r\n/**\r\n * Apply the data from a user-generated update() call\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport function syncTreeApplyUserMerge(syncTree, path, changedChildren, writeId) {\r\n    // Record pending merge.\r\n    writeTreeAddMerge(syncTree.pendingWriteTree_, path, changedChildren, writeId);\r\n    const changeTree = ImmutableTree.fromObject(changedChildren);\r\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceUser(), path, changeTree));\r\n}\r\n/**\r\n * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\r\n *\r\n * @param revert - True if the given write failed and needs to be reverted\r\n * @returns Events to raise.\r\n */\r\nexport function syncTreeAckUserWrite(syncTree, writeId, revert = false) {\r\n    const write = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);\r\n    const needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);\r\n    if (!needToReevaluate) {\r\n        return [];\r\n    }\r\n    else {\r\n        let affectedTree = new ImmutableTree(null);\r\n        if (write.snap != null) {\r\n            // overwrite\r\n            affectedTree = affectedTree.set(newEmptyPath(), true);\r\n        }\r\n        else {\r\n            each(write.children, (pathString) => {\r\n                affectedTree = affectedTree.set(new Path(pathString), true);\r\n            });\r\n        }\r\n        return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write.path, affectedTree, revert));\r\n    }\r\n}\r\n/**\r\n * Apply new server data for the specified path..\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport function syncTreeApplyServerOverwrite(syncTree, path, newData) {\r\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));\r\n}\r\n/**\r\n * Apply new server data to be merged in at the specified path.\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport function syncTreeApplyServerMerge(syncTree, path, changedChildren) {\r\n    const changeTree = ImmutableTree.fromObject(changedChildren);\r\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));\r\n}\r\n/**\r\n * Apply a listen complete for a query\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport function syncTreeApplyListenComplete(syncTree, path) {\r\n    return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));\r\n}\r\n/**\r\n * Apply a listen complete for a tagged query\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport function syncTreeApplyTaggedListenComplete(syncTree, path, tag) {\r\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\r\n    if (queryKey) {\r\n        const r = syncTreeParseQueryKey_(queryKey);\r\n        const queryPath = r.path, queryId = r.queryId;\r\n        const relativePath = newRelativePath(queryPath, path);\r\n        const op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);\r\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\r\n    }\r\n    else {\r\n        // We've already removed the query. No big deal, ignore the update\r\n        return [];\r\n    }\r\n}\r\n/**\r\n * Remove event callback(s).\r\n *\r\n * If query is the default query, we'll check all queries for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\r\n *\r\n * @param eventRegistration - If null, all callbacks are removed.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @param skipListenerDedup - When performing a `get()`, we don't add any new listeners, so no\r\n *  deduping needs to take place. This flag allows toggling of that behavior\r\n * @returns Cancel events, if cancelError was provided.\r\n */\r\nexport function syncTreeRemoveEventRegistration(syncTree, query, eventRegistration, cancelError, skipListenerDedup = false) {\r\n    // Find the syncPoint first. Then deal with whether or not it has matching listeners\r\n    const path = query._path;\r\n    const maybeSyncPoint = syncTree.syncPointTree_.get(path);\r\n    let cancelEvents = [];\r\n    // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\r\n    // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\r\n    // not loadsAllData().\r\n    if (maybeSyncPoint &&\r\n        (query._queryIdentifier === 'default' ||\r\n            syncPointViewExistsForQuery(maybeSyncPoint, query))) {\r\n        const removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query, eventRegistration, cancelError);\r\n        if (syncPointIsEmpty(maybeSyncPoint)) {\r\n            syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);\r\n        }\r\n        const removed = removedAndEvents.removed;\r\n        cancelEvents = removedAndEvents.events;\r\n        if (!skipListenerDedup) {\r\n            /**\r\n             * We may have just removed one of many listeners and can short-circuit this whole process\r\n             * We may also not have removed a default listener, in which case all of the descendant listeners should already be\r\n             * properly set up.\r\n             */\r\n            // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\r\n            // queryId === 'default'\r\n            const removingDefault = -1 !==\r\n                removed.findIndex(query => {\r\n                    return query._queryParams.loadsAllData();\r\n                });\r\n            const covered = syncTree.syncPointTree_.findOnPath(path, (relativePath, parentSyncPoint) => syncPointHasCompleteView(parentSyncPoint));\r\n            if (removingDefault && !covered) {\r\n                const subtree = syncTree.syncPointTree_.subtree(path);\r\n                // There are potentially child listeners. Determine what if any listens we need to send before executing the\r\n                // removal\r\n                if (!subtree.isEmpty()) {\r\n                    // We need to fold over our subtree and collect the listeners to send\r\n                    const newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);\r\n                    // Ok, we've collected all the listens we need. Set them up.\r\n                    for (let i = 0; i < newViews.length; ++i) {\r\n                        const view = newViews[i], newQuery = view.query;\r\n                        const listener = syncTreeCreateListenerForView_(syncTree, view);\r\n                        syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery(syncTree, newQuery), listener.hashFn, listener.onComplete);\r\n                    }\r\n                }\r\n                // Otherwise there's nothing below us, so nothing we need to start listening on\r\n            }\r\n            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\r\n            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\r\n            // Also, note that if we have a cancelError, it's already been removed at the provider level.\r\n            if (!covered && removed.length > 0 && !cancelError) {\r\n                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\r\n                // default. Otherwise, we need to iterate through and cancel each individual query\r\n                if (removingDefault) {\r\n                    // We don't tag default listeners\r\n                    const defaultTag = null;\r\n                    syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query), defaultTag);\r\n                }\r\n                else {\r\n                    removed.forEach((queryToRemove) => {\r\n                        const tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));\r\n                        syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        // Now, clear all of the tags we're tracking for the removed listens\r\n        syncTreeRemoveTags_(syncTree, removed);\r\n    }\r\n    else {\r\n        // No-op, this listener must've been already removed\r\n    }\r\n    return cancelEvents;\r\n}\r\n/**\r\n * Apply new server data for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport function syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {\r\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\r\n    if (queryKey != null) {\r\n        const r = syncTreeParseQueryKey_(queryKey);\r\n        const queryPath = r.path, queryId = r.queryId;\r\n        const relativePath = newRelativePath(queryPath, path);\r\n        const op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);\r\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\r\n    }\r\n    else {\r\n        // Query must have been removed already\r\n        return [];\r\n    }\r\n}\r\n/**\r\n * Apply server data to be merged in for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport function syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {\r\n    const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);\r\n    if (queryKey) {\r\n        const r = syncTreeParseQueryKey_(queryKey);\r\n        const queryPath = r.path, queryId = r.queryId;\r\n        const relativePath = newRelativePath(queryPath, path);\r\n        const changeTree = ImmutableTree.fromObject(changedChildren);\r\n        const op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);\r\n        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);\r\n    }\r\n    else {\r\n        // We've already removed the query. No big deal, ignore the update\r\n        return [];\r\n    }\r\n}\r\n/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport function syncTreeAddEventRegistration(syncTree, query, eventRegistration, skipSetupListener = false) {\r\n    const path = query._path;\r\n    let serverCache = null;\r\n    let foundAncestorDefaultView = false;\r\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\r\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\r\n    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp) => {\r\n        const relativePath = newRelativePath(pathToSyncPoint, path);\r\n        serverCache =\r\n            serverCache || syncPointGetCompleteServerCache(sp, relativePath);\r\n        foundAncestorDefaultView =\r\n            foundAncestorDefaultView || syncPointHasCompleteView(sp);\r\n    });\r\n    let syncPoint = syncTree.syncPointTree_.get(path);\r\n    if (!syncPoint) {\r\n        syncPoint = new SyncPoint();\r\n        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);\r\n    }\r\n    else {\r\n        foundAncestorDefaultView =\r\n            foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);\r\n        serverCache =\r\n            serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\r\n    }\r\n    let serverCacheComplete;\r\n    if (serverCache != null) {\r\n        serverCacheComplete = true;\r\n    }\r\n    else {\r\n        serverCacheComplete = false;\r\n        serverCache = ChildrenNode.EMPTY_NODE;\r\n        const subtree = syncTree.syncPointTree_.subtree(path);\r\n        subtree.foreachChild((childName, childSyncPoint) => {\r\n            const completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());\r\n            if (completeCache) {\r\n                serverCache = serverCache.updateImmediateChild(childName, completeCache);\r\n            }\r\n        });\r\n    }\r\n    const viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query);\r\n    if (!viewAlreadyExists && !query._queryParams.loadsAllData()) {\r\n        // We need to track a tag for this query\r\n        const queryKey = syncTreeMakeQueryKey_(query);\r\n        assert(!syncTree.queryToTagMap.has(queryKey), 'View does not exist, but we have a tag');\r\n        const tag = syncTreeGetNextQueryTag_();\r\n        syncTree.queryToTagMap.set(queryKey, tag);\r\n        syncTree.tagToQueryMap.set(tag, queryKey);\r\n    }\r\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);\r\n    let events = syncPointAddEventRegistration(syncPoint, query, eventRegistration, writesCache, serverCache, serverCacheComplete);\r\n    if (!viewAlreadyExists && !foundAncestorDefaultView && !skipSetupListener) {\r\n        const view = syncPointViewForQuery(syncPoint, query);\r\n        events = events.concat(syncTreeSetupListener_(syncTree, query, view));\r\n    }\r\n    return events;\r\n}\r\n/**\r\n * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a\r\n * listener above it, we will get a false \"null\". This shouldn't be a problem because transactions will always\r\n * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->\r\n *     <incremented total> as the write is applied locally and then acknowledged at the server.\r\n *\r\n * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\r\n *\r\n * @param path - The path to the data we want\r\n * @param writeIdsToExclude - A specific set to be excluded\r\n */\r\nexport function syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {\r\n    const includeHiddenSets = true;\r\n    const writeTree = syncTree.pendingWriteTree_;\r\n    const serverCache = syncTree.syncPointTree_.findOnPath(path, (pathSoFar, syncPoint) => {\r\n        const relativePath = newRelativePath(pathSoFar, path);\r\n        const serverCache = syncPointGetCompleteServerCache(syncPoint, relativePath);\r\n        if (serverCache) {\r\n            return serverCache;\r\n        }\r\n    });\r\n    return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);\r\n}\r\nexport function syncTreeGetServerValue(syncTree, query) {\r\n    const path = query._path;\r\n    let serverCache = null;\r\n    // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\r\n    // Consider optimizing this once there's a better understanding of what actual behavior will be.\r\n    syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp) => {\r\n        const relativePath = newRelativePath(pathToSyncPoint, path);\r\n        serverCache =\r\n            serverCache || syncPointGetCompleteServerCache(sp, relativePath);\r\n    });\r\n    let syncPoint = syncTree.syncPointTree_.get(path);\r\n    if (!syncPoint) {\r\n        syncPoint = new SyncPoint();\r\n        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);\r\n    }\r\n    else {\r\n        serverCache =\r\n            serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\r\n    }\r\n    const serverCacheComplete = serverCache != null;\r\n    const serverCacheNode = serverCacheComplete\r\n        ? new CacheNode(serverCache, true, false)\r\n        : null;\r\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query._path);\r\n    const view = syncPointGetView(syncPoint, query, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);\r\n    return viewGetCompleteNode(view);\r\n}\r\n/**\r\n * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\r\n *\r\n * NOTES:\r\n * - Descendant SyncPoints will be visited first (since we raise events depth-first).\r\n *\r\n * - We call applyOperation() on each SyncPoint passing three things:\r\n *   1. A version of the Operation that has been made relative to the SyncPoint location.\r\n *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\r\n *   3. A snapshot Node with cached server data, if we have it.\r\n *\r\n * - We concatenate all of the events returned by each SyncPoint and return the result.\r\n */\r\nfunction syncTreeApplyOperationToSyncPoints_(syncTree, operation) {\r\n    return syncTreeApplyOperationHelper_(operation, syncTree.syncPointTree_, \r\n    /*serverCache=*/ null, writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath()));\r\n}\r\n/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */\r\nfunction syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {\r\n    if (pathIsEmpty(operation.path)) {\r\n        return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);\r\n    }\r\n    else {\r\n        const syncPoint = syncPointTree.get(newEmptyPath());\r\n        // If we don't have cached server data, see if we can get it from this SyncPoint.\r\n        if (serverCache == null && syncPoint != null) {\r\n            serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\r\n        }\r\n        let events = [];\r\n        const childName = pathGetFront(operation.path);\r\n        const childOperation = operation.operationForChild(childName);\r\n        const childTree = syncPointTree.children.get(childName);\r\n        if (childTree && childOperation) {\r\n            const childServerCache = serverCache\r\n                ? serverCache.getImmediateChild(childName)\r\n                : null;\r\n            const childWritesCache = writeTreeRefChild(writesCache, childName);\r\n            events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));\r\n        }\r\n        if (syncPoint) {\r\n            events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));\r\n        }\r\n        return events;\r\n    }\r\n}\r\n/**\r\n * Recursive helper for applyOperationToSyncPoints_\r\n */\r\nfunction syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {\r\n    const syncPoint = syncPointTree.get(newEmptyPath());\r\n    // If we don't have cached server data, see if we can get it from this SyncPoint.\r\n    if (serverCache == null && syncPoint != null) {\r\n        serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());\r\n    }\r\n    let events = [];\r\n    syncPointTree.children.inorderTraversal((childName, childTree) => {\r\n        const childServerCache = serverCache\r\n            ? serverCache.getImmediateChild(childName)\r\n            : null;\r\n        const childWritesCache = writeTreeRefChild(writesCache, childName);\r\n        const childOperation = operation.operationForChild(childName);\r\n        if (childOperation) {\r\n            events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));\r\n        }\r\n    });\r\n    if (syncPoint) {\r\n        events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));\r\n    }\r\n    return events;\r\n}\r\nfunction syncTreeCreateListenerForView_(syncTree, view) {\r\n    const query = view.query;\r\n    const tag = syncTreeTagForQuery(syncTree, query);\r\n    return {\r\n        hashFn: () => {\r\n            const cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;\r\n            return cache.hash();\r\n        },\r\n        onComplete: (status) => {\r\n            if (status === 'ok') {\r\n                if (tag) {\r\n                    return syncTreeApplyTaggedListenComplete(syncTree, query._path, tag);\r\n                }\r\n                else {\r\n                    return syncTreeApplyListenComplete(syncTree, query._path);\r\n                }\r\n            }\r\n            else {\r\n                // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\r\n                // Note that this may need to be scoped to just this listener if we change permissions on filtered children\r\n                const error = errorForServerCode(status, query);\r\n                return syncTreeRemoveEventRegistration(syncTree, query, \r\n                /*eventRegistration*/ null, error);\r\n            }\r\n        }\r\n    };\r\n}\r\n/**\r\n * Return the tag associated with the given query.\r\n */\r\nexport function syncTreeTagForQuery(syncTree, query) {\r\n    const queryKey = syncTreeMakeQueryKey_(query);\r\n    return syncTree.queryToTagMap.get(queryKey);\r\n}\r\n/**\r\n * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\r\n */\r\nfunction syncTreeMakeQueryKey_(query) {\r\n    return query._path.toString() + '$' + query._queryIdentifier;\r\n}\r\n/**\r\n * Return the query associated with the given tag, if we have one\r\n */\r\nfunction syncTreeQueryKeyForTag_(syncTree, tag) {\r\n    return syncTree.tagToQueryMap.get(tag);\r\n}\r\n/**\r\n * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\r\n */\r\nfunction syncTreeParseQueryKey_(queryKey) {\r\n    const splitIndex = queryKey.indexOf('$');\r\n    assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');\r\n    return {\r\n        queryId: queryKey.substr(splitIndex + 1),\r\n        path: new Path(queryKey.substr(0, splitIndex))\r\n    };\r\n}\r\n/**\r\n * A helper method to apply tagged operations\r\n */\r\nfunction syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {\r\n    const syncPoint = syncTree.syncPointTree_.get(queryPath);\r\n    assert(syncPoint, \"Missing sync point for query tag that we're tracking\");\r\n    const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);\r\n    return syncPointApplyOperation(syncPoint, operation, writesCache, null);\r\n}\r\n/**\r\n * This collapses multiple unfiltered views into a single view, since we only need a single\r\n * listener for them.\r\n */\r\nfunction syncTreeCollectDistinctViewsForSubTree_(subtree) {\r\n    return subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {\r\n        if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {\r\n            const completeView = syncPointGetCompleteView(maybeChildSyncPoint);\r\n            return [completeView];\r\n        }\r\n        else {\r\n            // No complete view here, flatten any deeper listens into an array\r\n            let views = [];\r\n            if (maybeChildSyncPoint) {\r\n                views = syncPointGetQueryViews(maybeChildSyncPoint);\r\n            }\r\n            each(childMap, (_key, childViews) => {\r\n                views = views.concat(childViews);\r\n            });\r\n            return views;\r\n        }\r\n    });\r\n}\r\n/**\r\n * Normalizes a query to a query we send the server for listening\r\n *\r\n * @returns The normalized query\r\n */\r\nfunction syncTreeQueryForListening_(query) {\r\n    if (query._queryParams.loadsAllData() && !query._queryParams.isDefault()) {\r\n        // We treat queries that load all data as default queries\r\n        // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\r\n        // from Query\r\n        return new (syncTreeGetReferenceConstructor())(query._repo, query._path);\r\n    }\r\n    else {\r\n        return query;\r\n    }\r\n}\r\nfunction syncTreeRemoveTags_(syncTree, queries) {\r\n    for (let j = 0; j < queries.length; ++j) {\r\n        const removedQuery = queries[j];\r\n        if (!removedQuery._queryParams.loadsAllData()) {\r\n            // We should have a tag for this\r\n            const removedQueryKey = syncTreeMakeQueryKey_(removedQuery);\r\n            const removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);\r\n            syncTree.queryToTagMap.delete(removedQueryKey);\r\n            syncTree.tagToQueryMap.delete(removedQueryTag);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Static accessor for query tags.\r\n */\r\nfunction syncTreeGetNextQueryTag_() {\r\n    return syncTreeNextQueryTag_++;\r\n}\r\n/**\r\n * For a given new listen, manage the de-duplication of outstanding subscriptions.\r\n *\r\n * @returns This method can return events to support synchronous data sources\r\n */\r\nfunction syncTreeSetupListener_(syncTree, query, view) {\r\n    const path = query._path;\r\n    const tag = syncTreeTagForQuery(syncTree, query);\r\n    const listener = syncTreeCreateListenerForView_(syncTree, view);\r\n    const events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query), tag, listener.hashFn, listener.onComplete);\r\n    const subtree = syncTree.syncPointTree_.subtree(path);\r\n    // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\r\n    // may need to shadow other listens as well.\r\n    if (tag) {\r\n        assert(!syncPointHasCompleteView(subtree.value), \"If we're adding a query, it shouldn't be shadowed\");\r\n    }\r\n    else {\r\n        // Shadow everything at or below this location, this is a default listener.\r\n        const queriesToStop = subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {\r\n            if (!pathIsEmpty(relativePath) &&\r\n                maybeChildSyncPoint &&\r\n                syncPointHasCompleteView(maybeChildSyncPoint)) {\r\n                return [syncPointGetCompleteView(maybeChildSyncPoint).query];\r\n            }\r\n            else {\r\n                // No default listener here, flatten any deeper queries into an array\r\n                let queries = [];\r\n                if (maybeChildSyncPoint) {\r\n                    queries = queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map(view => view.query));\r\n                }\r\n                each(childMap, (_key, childQueries) => {\r\n                    queries = queries.concat(childQueries);\r\n                });\r\n                return queries;\r\n            }\r\n        });\r\n        for (let i = 0; i < queriesToStop.length; ++i) {\r\n            const queryToStop = queriesToStop[i];\r\n            syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery(syncTree, queryToStop));\r\n        }\r\n    }\r\n    return events;\r\n}\r\n//# sourceMappingURL=SyncTree.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/util/dist/index.d.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/api/Reference.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/operation/AckUserWrite.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/operation/ListenComplete.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/operation/Merge.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/operation/Operation.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/operation/Overwrite.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/snap/ChildrenNode.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/snap/Node.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/SyncPoint.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/ImmutableTree.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/Path.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/util.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/view/CacheNode.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/view/Event.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/view/EventRegistration.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/view/View.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/WriteTree.ts"],"map":"{\"version\":3,\"file\":\"SyncTree.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/core/SyncTree.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/core/SyncTree.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { ReferenceConstructor } from '../api/Reference';\r\nimport { Node } from './snap/Node';\r\nimport { SyncPoint } from './SyncPoint';\r\nimport { ImmutableTree } from './util/ImmutableTree';\r\nimport { Path } from './util/Path';\r\nimport { Event } from './view/Event';\r\nimport { EventRegistration, QueryContext } from './view/EventRegistration';\r\nimport { WriteTree } from './WriteTree';\r\nexport declare function syncTreeSetReferenceConstructor(val: ReferenceConstructor): void;\r\nexport interface ListenProvider {\r\n    startListening(query: QueryContext, tag: number | null, hashFn: () => string, onComplete: (a: string, b?: unknown) => Event[]): Event[];\r\n    stopListening(a: QueryContext, b: number | null): void;\r\n}\r\nexport declare function resetSyncTreeTag(): void;\r\n/**\r\n * SyncTree is the central class for managing event callback registration, data caching, views\r\n * (query processing), and event generation.  There are typically two SyncTree instances for\r\n * each Repo, one for the normal Firebase data, and one for the .info data.\r\n *\r\n * It has a number of responsibilities, including:\r\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\r\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\r\n *    (applyUserOverwrite(), applyUserMerge()).\r\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\r\n *    applyServerMerge()).\r\n *  - Generating user-facing events for server and user changes (all of the apply* methods\r\n *    return the set of events that need to be raised as a result).\r\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\r\n *    to the correct set of paths and queries to satisfy the current set of user event\r\n *    callbacks (listens are started/stopped using the provided listenProvider).\r\n *\r\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\r\n * events are returned to the caller rather than raised synchronously.\r\n *\r\n */\r\nexport declare class SyncTree {\r\n    listenProvider_: ListenProvider;\r\n    /**\r\n     * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\r\n     */\r\n    syncPointTree_: ImmutableTree<SyncPoint>;\r\n    /**\r\n     * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\r\n     */\r\n    pendingWriteTree_: WriteTree;\r\n    readonly tagToQueryMap: Map<number, string>;\r\n    readonly queryToTagMap: Map<string, number>;\r\n    /**\r\n     * @param listenProvider_ - Used by SyncTree to start / stop listening\r\n     *   to server data.\r\n     */\r\n    constructor(listenProvider_: ListenProvider);\r\n}\r\n/**\r\n * Apply the data changes for a user-generated set() or transaction() call.\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport declare function syncTreeApplyUserOverwrite(syncTree: SyncTree, path: Path, newData: Node, writeId: number, visible?: boolean): Event[];\r\n/**\r\n * Apply the data from a user-generated update() call\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport declare function syncTreeApplyUserMerge(syncTree: SyncTree, path: Path, changedChildren: {\r\n    [k: string]: Node;\r\n}, writeId: number): Event[];\r\n/**\r\n * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\r\n *\r\n * @param revert - True if the given write failed and needs to be reverted\r\n * @returns Events to raise.\r\n */\r\nexport declare function syncTreeAckUserWrite(syncTree: SyncTree, writeId: number, revert?: boolean): Event[];\r\n/**\r\n * Apply new server data for the specified path..\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport declare function syncTreeApplyServerOverwrite(syncTree: SyncTree, path: Path, newData: Node): Event[];\r\n/**\r\n * Apply new server data to be merged in at the specified path.\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport declare function syncTreeApplyServerMerge(syncTree: SyncTree, path: Path, changedChildren: {\r\n    [k: string]: Node;\r\n}): Event[];\r\n/**\r\n * Apply a listen complete for a query\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport declare function syncTreeApplyListenComplete(syncTree: SyncTree, path: Path): Event[];\r\n/**\r\n * Apply a listen complete for a tagged query\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport declare function syncTreeApplyTaggedListenComplete(syncTree: SyncTree, path: Path, tag: number): Event[];\r\n/**\r\n * Remove event callback(s).\r\n *\r\n * If query is the default query, we'll check all queries for the specified eventRegistration.\r\n * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\r\n *\r\n * @param eventRegistration - If null, all callbacks are removed.\r\n * @param cancelError - If a cancelError is provided, appropriate cancel events will be returned.\r\n * @param skipListenerDedup - When performing a `get()`, we don't add any new listeners, so no\r\n *  deduping needs to take place. This flag allows toggling of that behavior\r\n * @returns Cancel events, if cancelError was provided.\r\n */\r\nexport declare function syncTreeRemoveEventRegistration(syncTree: SyncTree, query: QueryContext, eventRegistration: EventRegistration | null, cancelError?: Error, skipListenerDedup?: boolean): Event[];\r\n/**\r\n * Apply new server data for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport declare function syncTreeApplyTaggedQueryOverwrite(syncTree: SyncTree, path: Path, snap: Node, tag: number): Event[];\r\n/**\r\n * Apply server data to be merged in for the specified tagged query.\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport declare function syncTreeApplyTaggedQueryMerge(syncTree: SyncTree, path: Path, changedChildren: {\r\n    [k: string]: Node;\r\n}, tag: number): Event[];\r\n/**\r\n * Add an event callback for the specified query.\r\n *\r\n * @returns Events to raise.\r\n */\r\nexport declare function syncTreeAddEventRegistration(syncTree: SyncTree, query: QueryContext, eventRegistration: EventRegistration, skipSetupListener?: boolean): Event[];\r\n/**\r\n * Returns a complete cache, if we have one, of the data at a particular path. If the location does not have a\r\n * listener above it, we will get a false \"null\". This shouldn't be a problem because transactions will always\r\n * have a listener above, and atomic operations would correctly show a jitter of <increment value> ->\r\n *     <incremented total> as the write is applied locally and then acknowledged at the server.\r\n *\r\n * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\r\n *\r\n * @param path - The path to the data we want\r\n * @param writeIdsToExclude - A specific set to be excluded\r\n */\r\nexport declare function syncTreeCalcCompleteEventCache(syncTree: SyncTree, path: Path, writeIdsToExclude?: number[]): Node;\r\nexport declare function syncTreeGetServerValue(syncTree: SyncTree, query: QueryContext): Node | null;\r\n/**\r\n * Return the tag associated with the given query.\r\n */\r\nexport declare function syncTreeTagForQuery(syncTree: SyncTree, query: QueryContext): number | null;\r\n"}}
