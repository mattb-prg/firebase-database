{"code":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { contains, safeGet } from '@firebase/util';\r\nimport { Path, pathGetFront, pathPopFront } from './Path';\r\nimport { each } from './util';\r\n/**\r\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\r\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\r\n * children.\r\n */\r\nexport class Tree {\r\n    /**\r\n     * @param name - Optional name of the node.\r\n     * @param parent - Optional parent node.\r\n     * @param node - Optional node to wrap.\r\n     */\r\n    constructor(name = '', parent = null, node = { children: {}, childCount: 0 }) {\r\n        this.name = name;\r\n        this.parent = parent;\r\n        this.node = node;\r\n    }\r\n}\r\n/**\r\n * Returns a sub-Tree for the given path.\r\n *\r\n * @param pathObj - Path to look up.\r\n * @returns Tree for path.\r\n */\r\nexport function treeSubTree(tree, pathObj) {\r\n    // TODO: Require pathObj to be Path?\r\n    let path = pathObj instanceof Path ? pathObj : new Path(pathObj);\r\n    let child = tree, next = pathGetFront(path);\r\n    while (next !== null) {\r\n        const childNode = safeGet(child.node.children, next) || {\r\n            children: {},\r\n            childCount: 0\r\n        };\r\n        child = new Tree(next, child, childNode);\r\n        path = pathPopFront(path);\r\n        next = pathGetFront(path);\r\n    }\r\n    return child;\r\n}\r\n/**\r\n * Returns the data associated with this tree node.\r\n *\r\n * @returns The data or null if no data exists.\r\n */\r\nexport function treeGetValue(tree) {\r\n    return tree.node.value;\r\n}\r\n/**\r\n * Sets data to this tree node.\r\n *\r\n * @param value - Value to set.\r\n */\r\nexport function treeSetValue(tree, value) {\r\n    tree.node.value = value;\r\n    treeUpdateParents(tree);\r\n}\r\n/**\r\n * @returns Whether the tree has any children.\r\n */\r\nexport function treeHasChildren(tree) {\r\n    return tree.node.childCount > 0;\r\n}\r\n/**\r\n * @returns Whethe rthe tree is empty (no value or children).\r\n */\r\nexport function treeIsEmpty(tree) {\r\n    return treeGetValue(tree) === undefined && !treeHasChildren(tree);\r\n}\r\n/**\r\n * Calls action for each child of this tree node.\r\n *\r\n * @param action - Action to be called for each child.\r\n */\r\nexport function treeForEachChild(tree, action) {\r\n    each(tree.node.children, (child, childTree) => {\r\n        action(new Tree(child, tree, childTree));\r\n    });\r\n}\r\n/**\r\n * Does a depth-first traversal of this node's descendants, calling action for each one.\r\n *\r\n * @param action - Action to be called for each child.\r\n * @param includeSelf - Whether to call action on this node as well. Defaults to\r\n *   false.\r\n * @param childrenFirst - Whether to call action on children before calling it on\r\n *   parent.\r\n */\r\nexport function treeForEachDescendant(tree, action, includeSelf, childrenFirst) {\r\n    if (includeSelf && !childrenFirst) {\r\n        action(tree);\r\n    }\r\n    treeForEachChild(tree, child => {\r\n        treeForEachDescendant(child, action, true, childrenFirst);\r\n    });\r\n    if (includeSelf && childrenFirst) {\r\n        action(tree);\r\n    }\r\n}\r\n/**\r\n * Calls action on each ancestor node.\r\n *\r\n * @param action - Action to be called on each parent; return\r\n *   true to abort.\r\n * @param includeSelf - Whether to call action on this node as well.\r\n * @returns true if the action callback returned true.\r\n */\r\nexport function treeForEachAncestor(tree, action, includeSelf) {\r\n    let node = includeSelf ? tree : tree.parent;\r\n    while (node !== null) {\r\n        if (action(node)) {\r\n            return true;\r\n        }\r\n        node = node.parent;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Does a depth-first traversal of this node's descendants.  When a descendant with a value\r\n * is found, action is called on it and traversal does not continue inside the node.\r\n * Action is *not* called on this node.\r\n *\r\n * @param action - Action to be called for each child.\r\n */\r\nexport function treeForEachImmediateDescendantWithValue(tree, action) {\r\n    treeForEachChild(tree, child => {\r\n        if (treeGetValue(child) !== undefined) {\r\n            action(child);\r\n        }\r\n        else {\r\n            treeForEachImmediateDescendantWithValue(child, action);\r\n        }\r\n    });\r\n}\r\n/**\r\n * @returns The path of this tree node, as a Path.\r\n */\r\nexport function treeGetPath(tree) {\r\n    return new Path(tree.parent === null\r\n        ? tree.name\r\n        : treeGetPath(tree.parent) + '/' + tree.name);\r\n}\r\n/**\r\n * Adds or removes this child from its parent based on whether it's empty or not.\r\n */\r\nfunction treeUpdateParents(tree) {\r\n    if (tree.parent !== null) {\r\n        treeUpdateChild(tree.parent, tree.name, tree);\r\n    }\r\n}\r\n/**\r\n * Adds or removes the passed child to this tree node, depending on whether it's empty.\r\n *\r\n * @param childName - The name of the child to update.\r\n * @param child - The child to update.\r\n */\r\nfunction treeUpdateChild(tree, childName, child) {\r\n    const childEmpty = treeIsEmpty(child);\r\n    const childExists = contains(tree.node.children, childName);\r\n    if (childEmpty && childExists) {\r\n        delete tree.node.children[childName];\r\n        tree.node.childCount--;\r\n        treeUpdateParents(tree);\r\n    }\r\n    else if (!childEmpty && !childExists) {\r\n        tree.node.children[childName] = child.node;\r\n        tree.node.childCount++;\r\n        treeUpdateParents(tree);\r\n    }\r\n}\r\n//# sourceMappingURL=Tree.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/util/dist/index.d.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/Path.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/util.ts"],"map":"{\"version\":3,\"file\":\"Tree.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/core/util/Tree.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/core/util/Tree.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { Path } from './Path';\r\n/**\r\n * Node in a Tree.\r\n */\r\nexport interface TreeNode<T> {\r\n    children: Record<string, TreeNode<T>>;\r\n    childCount: number;\r\n    value?: T;\r\n}\r\n/**\r\n * A light-weight tree, traversable by path.  Nodes can have both values and children.\r\n * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty\r\n * children.\r\n */\r\nexport declare class Tree<T> {\r\n    readonly name: string;\r\n    readonly parent: Tree<T> | null;\r\n    node: TreeNode<T>;\r\n    /**\r\n     * @param name - Optional name of the node.\r\n     * @param parent - Optional parent node.\r\n     * @param node - Optional node to wrap.\r\n     */\r\n    constructor(name?: string, parent?: Tree<T> | null, node?: TreeNode<T>);\r\n}\r\n/**\r\n * Returns a sub-Tree for the given path.\r\n *\r\n * @param pathObj - Path to look up.\r\n * @returns Tree for path.\r\n */\r\nexport declare function treeSubTree<T>(tree: Tree<T>, pathObj: string | Path): Tree<T>;\r\n/**\r\n * Returns the data associated with this tree node.\r\n *\r\n * @returns The data or null if no data exists.\r\n */\r\nexport declare function treeGetValue<T>(tree: Tree<T>): T | undefined;\r\n/**\r\n * Sets data to this tree node.\r\n *\r\n * @param value - Value to set.\r\n */\r\nexport declare function treeSetValue<T>(tree: Tree<T>, value: T | undefined): void;\r\n/**\r\n * @returns Whether the tree has any children.\r\n */\r\nexport declare function treeHasChildren<T>(tree: Tree<T>): boolean;\r\n/**\r\n * @returns Whethe rthe tree is empty (no value or children).\r\n */\r\nexport declare function treeIsEmpty<T>(tree: Tree<T>): boolean;\r\n/**\r\n * Calls action for each child of this tree node.\r\n *\r\n * @param action - Action to be called for each child.\r\n */\r\nexport declare function treeForEachChild<T>(tree: Tree<T>, action: (tree: Tree<T>) => void): void;\r\n/**\r\n * Does a depth-first traversal of this node's descendants, calling action for each one.\r\n *\r\n * @param action - Action to be called for each child.\r\n * @param includeSelf - Whether to call action on this node as well. Defaults to\r\n *   false.\r\n * @param childrenFirst - Whether to call action on children before calling it on\r\n *   parent.\r\n */\r\nexport declare function treeForEachDescendant<T>(tree: Tree<T>, action: (tree: Tree<T>) => void, includeSelf?: boolean, childrenFirst?: boolean): void;\r\n/**\r\n * Calls action on each ancestor node.\r\n *\r\n * @param action - Action to be called on each parent; return\r\n *   true to abort.\r\n * @param includeSelf - Whether to call action on this node as well.\r\n * @returns true if the action callback returned true.\r\n */\r\nexport declare function treeForEachAncestor<T>(tree: Tree<T>, action: (tree: Tree<T>) => unknown, includeSelf?: boolean): boolean;\r\n/**\r\n * Does a depth-first traversal of this node's descendants.  When a descendant with a value\r\n * is found, action is called on it and traversal does not continue inside the node.\r\n * Action is *not* called on this node.\r\n *\r\n * @param action - Action to be called for each child.\r\n */\r\nexport declare function treeForEachImmediateDescendantWithValue<T>(tree: Tree<T>, action: (tree: Tree<T>) => void): void;\r\n/**\r\n * @returns The path of this tree node, as a Path.\r\n */\r\nexport declare function treeGetPath<T>(tree: Tree<T>): any;\r\n"}}
