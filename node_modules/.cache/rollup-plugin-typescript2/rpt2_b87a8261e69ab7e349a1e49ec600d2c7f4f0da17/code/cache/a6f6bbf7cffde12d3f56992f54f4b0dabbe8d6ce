{"code":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\r\nimport { Path, pathGetFront, pathIsEmpty, pathPopFront } from './util/Path';\r\nexport function newSparseSnapshotTree() {\r\n    return {\r\n        value: null,\r\n        children: new Map()\r\n    };\r\n}\r\n/**\r\n * Gets the node stored at the given path if one exists.\r\n * Only seems to be used in tests.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @returns The retrieved node, or null.\r\n */\r\nexport function sparseSnapshotTreeFind(sparseSnapshotTree, path) {\r\n    if (sparseSnapshotTree.value != null) {\r\n        return sparseSnapshotTree.value.getChild(path);\r\n    }\r\n    else if (!pathIsEmpty(path) && sparseSnapshotTree.children.size > 0) {\r\n        const childKey = pathGetFront(path);\r\n        path = pathPopFront(path);\r\n        if (sparseSnapshotTree.children.has(childKey)) {\r\n            const childTree = sparseSnapshotTree.children.get(childKey);\r\n            return sparseSnapshotTreeFind(childTree, path);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * Stores the given node at the specified path. If there is already a node\r\n * at a shallower path, it merges the new data into that snapshot node.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @param data - The new data, or null.\r\n */\r\nexport function sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {\r\n    if (pathIsEmpty(path)) {\r\n        sparseSnapshotTree.value = data;\r\n        sparseSnapshotTree.children.clear();\r\n    }\r\n    else if (sparseSnapshotTree.value !== null) {\r\n        sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);\r\n    }\r\n    else {\r\n        const childKey = pathGetFront(path);\r\n        if (!sparseSnapshotTree.children.has(childKey)) {\r\n            sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());\r\n        }\r\n        const child = sparseSnapshotTree.children.get(childKey);\r\n        path = pathPopFront(path);\r\n        sparseSnapshotTreeRemember(child, path, data);\r\n    }\r\n}\r\n/**\r\n * Purge the data at path from the cache.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @returns True if this node should now be removed.\r\n */\r\nexport function sparseSnapshotTreeForget(sparseSnapshotTree, path) {\r\n    if (pathIsEmpty(path)) {\r\n        sparseSnapshotTree.value = null;\r\n        sparseSnapshotTree.children.clear();\r\n        return true;\r\n    }\r\n    else {\r\n        if (sparseSnapshotTree.value !== null) {\r\n            if (sparseSnapshotTree.value.isLeafNode()) {\r\n                // We're trying to forget a node that doesn't exist\r\n                return false;\r\n            }\r\n            else {\r\n                const value = sparseSnapshotTree.value;\r\n                sparseSnapshotTree.value = null;\r\n                value.forEachChild(PRIORITY_INDEX, (key, tree) => {\r\n                    sparseSnapshotTreeRemember(sparseSnapshotTree, new Path(key), tree);\r\n                });\r\n                return sparseSnapshotTreeForget(sparseSnapshotTree, path);\r\n            }\r\n        }\r\n        else if (sparseSnapshotTree.children.size > 0) {\r\n            const childKey = pathGetFront(path);\r\n            path = pathPopFront(path);\r\n            if (sparseSnapshotTree.children.has(childKey)) {\r\n                const safeToRemove = sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey), path);\r\n                if (safeToRemove) {\r\n                    sparseSnapshotTree.children.delete(childKey);\r\n                }\r\n            }\r\n            return sparseSnapshotTree.children.size === 0;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Recursively iterates through all of the stored tree and calls the\r\n * callback on each one.\r\n *\r\n * @param prefixPath - Path to look up node for.\r\n * @param func - The function to invoke for each tree.\r\n */\r\nexport function sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {\r\n    if (sparseSnapshotTree.value !== null) {\r\n        func(prefixPath, sparseSnapshotTree.value);\r\n    }\r\n    else {\r\n        sparseSnapshotTreeForEachChild(sparseSnapshotTree, (key, tree) => {\r\n            const path = new Path(prefixPath.toString() + '/' + key);\r\n            sparseSnapshotTreeForEachTree(tree, path, func);\r\n        });\r\n    }\r\n}\r\n/**\r\n * Iterates through each immediate child and triggers the callback.\r\n * Only seems to be used in tests.\r\n *\r\n * @param func - The function to invoke for each child.\r\n */\r\nexport function sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {\r\n    sparseSnapshotTree.children.forEach((tree, key) => {\r\n        func(key, tree);\r\n    });\r\n}\r\n//# sourceMappingURL=SparseSnapshotTree.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/snap/indexes/PriorityIndex.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/snap/Node.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/Path.ts"],"map":"{\"version\":3,\"file\":\"SparseSnapshotTree.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/core/SparseSnapshotTree.ts\"],\"names\":[],\"mappings\":\"AAAA;;;;;;;;;;;;;;;GAeG;AAEH,OAAO,EAAE,cAAc,EAAE,MAAM,8BAA8B,CAAC;AAE9D,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,WAAW,EAAE,YAAY,EAAE,MAAM,aAAa,CAAC;AAU5E,MAAM,UAAU,qBAAqB;IACnC,OAAO;QACL,KAAK,EAAE,IAAI;QACX,QAAQ,EAAE,IAAI,GAAG,EAAE;KACpB,CAAC;AACJ,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,sBAAsB,CACpC,kBAAsC,EACtC,IAAU;IAEV,IAAI,kBAAkB,CAAC,KAAK,IAAI,IAAI,EAAE;QACpC,OAAO,kBAAkB,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;KAChD;SAAM,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,kBAAkB,CAAC,QAAQ,CAAC,IAAI,GAAG,CAAC,EAAE;QACrE,MAAM,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;QACpC,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;QAC1B,IAAI,kBAAkB,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;YAC7C,MAAM,SAAS,GAAG,kBAAkB,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YAC5D,OAAO,sBAAsB,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;SAChD;aAAM;YACL,OAAO,IAAI,CAAC;SACb;KACF;SAAM;QACL,OAAO,IAAI,CAAC;KACb;AACH,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,0BAA0B,CACxC,kBAAsC,EACtC,IAAU,EACV,IAAU;IAEV,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;QACrB,kBAAkB,CAAC,KAAK,GAAG,IAAI,CAAC;QAChC,kBAAkB,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;KACrC;SAAM,IAAI,kBAAkB,CAAC,KAAK,KAAK,IAAI,EAAE;QAC5C,kBAAkB,CAAC,KAAK,GAAG,kBAAkB,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;KAC7E;SAAM;QACL,MAAM,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;QACpC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;YAC9C,kBAAkB,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,EAAE,qBAAqB,EAAE,CAAC,CAAC;SACpE;QAED,MAAM,KAAK,GAAG,kBAAkB,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QACxD,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;QAC1B,0BAA0B,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;KAC/C;AACH,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,wBAAwB,CACtC,kBAAsC,EACtC,IAAU;IAEV,IAAI,WAAW,CAAC,IAAI,CAAC,EAAE;QACrB,kBAAkB,CAAC,KAAK,GAAG,IAAI,CAAC;QAChC,kBAAkB,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;QACpC,OAAO,IAAI,CAAC;KACb;SAAM;QACL,IAAI,kBAAkB,CAAC,KAAK,KAAK,IAAI,EAAE;YACrC,IAAI,kBAAkB,CAAC,KAAK,CAAC,UAAU,EAAE,EAAE;gBACzC,mDAAmD;gBACnD,OAAO,KAAK,CAAC;aACd;iBAAM;gBACL,MAAM,KAAK,GAAG,kBAAkB,CAAC,KAAK,CAAC;gBACvC,kBAAkB,CAAC,KAAK,GAAG,IAAI,CAAC;gBAEhC,KAAK,CAAC,YAAY,CAAC,cAAc,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE;oBAC/C,0BAA0B,CAAC,kBAAkB,EAAE,IAAI,IAAI,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC;gBACtE,CAAC,CAAC,CAAC;gBAEH,OAAO,wBAAwB,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC;aAC3D;SACF;aAAM,IAAI,kBAAkB,CAAC,QAAQ,CAAC,IAAI,GAAG,CAAC,EAAE;YAC/C,MAAM,QAAQ,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;YACpC,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC;YAC1B,IAAI,kBAAkB,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE;gBAC7C,MAAM,YAAY,GAAG,wBAAwB,CAC3C,kBAAkB,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EACzC,IAAI,CACL,CAAC;gBACF,IAAI,YAAY,EAAE;oBAChB,kBAAkB,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;iBAC9C;aACF;YAED,OAAO,kBAAkB,CAAC,QAAQ,CAAC,IAAI,KAAK,CAAC,CAAC;SAC/C;aAAM;YACL,OAAO,IAAI,CAAC;SACb;KACF;AACH,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,6BAA6B,CAC3C,kBAAsC,EACtC,UAAgB,EAChB,IAAmC;IAEnC,IAAI,kBAAkB,CAAC,KAAK,KAAK,IAAI,EAAE;QACrC,IAAI,CAAC,UAAU,EAAE,kBAAkB,CAAC,KAAK,CAAC,CAAC;KAC5C;SAAM;QACL,8BAA8B,CAAC,kBAAkB,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE;YAC/D,MAAM,IAAI,GAAG,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;YACzD,6BAA6B,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QAClD,CAAC,CAAC,CAAC;KACJ;AACH,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,8BAA8B,CAC5C,kBAAsC,EACtC,IAAgD;IAEhD,kBAAkB,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,GAAG,EAAE,EAAE;QAChD,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;IAClB,CAAC,CAAC,CAAC;AACL,CAAC\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/core/SparseSnapshotTree.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { Node } from './snap/Node';\r\nimport { Path } from './util/Path';\r\n/**\r\n * Helper class to store a sparse set of snapshots.\r\n */\r\nexport interface SparseSnapshotTree {\r\n    value: Node | null;\r\n    readonly children: Map<string, SparseSnapshotTree>;\r\n}\r\nexport declare function newSparseSnapshotTree(): SparseSnapshotTree;\r\n/**\r\n * Gets the node stored at the given path if one exists.\r\n * Only seems to be used in tests.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @returns The retrieved node, or null.\r\n */\r\nexport declare function sparseSnapshotTreeFind(sparseSnapshotTree: SparseSnapshotTree, path: Path): Node | null;\r\n/**\r\n * Stores the given node at the specified path. If there is already a node\r\n * at a shallower path, it merges the new data into that snapshot node.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @param data - The new data, or null.\r\n */\r\nexport declare function sparseSnapshotTreeRemember(sparseSnapshotTree: SparseSnapshotTree, path: Path, data: Node): void;\r\n/**\r\n * Purge the data at path from the cache.\r\n *\r\n * @param path - Path to look up snapshot for.\r\n * @returns True if this node should now be removed.\r\n */\r\nexport declare function sparseSnapshotTreeForget(sparseSnapshotTree: SparseSnapshotTree, path: Path): boolean;\r\n/**\r\n * Recursively iterates through all of the stored tree and calls the\r\n * callback on each one.\r\n *\r\n * @param prefixPath - Path to look up node for.\r\n * @param func - The function to invoke for each tree.\r\n */\r\nexport declare function sparseSnapshotTreeForEachTree(sparseSnapshotTree: SparseSnapshotTree, prefixPath: Path, func: (a: Path, b: Node) => unknown): void;\r\n/**\r\n * Iterates through each immediate child and triggers the callback.\r\n * Only seems to be used in tests.\r\n *\r\n * @param func - The function to invoke for each child.\r\n */\r\nexport declare function sparseSnapshotTreeForEachChild(sparseSnapshotTree: SparseSnapshotTree, func: (a: string, b: SparseSnapshotTree) => void): void;\r\n"}}
