{"code":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { newEmptyPath, Path, pathChild, pathGetFront, pathIsEmpty, pathPopFront } from './Path';\r\nimport { SortedMap } from './SortedMap';\r\nimport { each, stringCompare } from './util';\r\nlet emptyChildrenSingleton;\r\n/**\r\n * Singleton empty children collection.\r\n *\r\n */\r\nconst EmptyChildren = () => {\r\n    if (!emptyChildrenSingleton) {\r\n        emptyChildrenSingleton = new SortedMap(stringCompare);\r\n    }\r\n    return emptyChildrenSingleton;\r\n};\r\n/**\r\n * A tree with immutable elements.\r\n */\r\nexport class ImmutableTree {\r\n    constructor(value, children = EmptyChildren()) {\r\n        this.value = value;\r\n        this.children = children;\r\n    }\r\n    static fromObject(obj) {\r\n        let tree = new ImmutableTree(null);\r\n        each(obj, (childPath, childSnap) => {\r\n            tree = tree.set(new Path(childPath), childSnap);\r\n        });\r\n        return tree;\r\n    }\r\n    /**\r\n     * True if the value is empty and there are no children\r\n     */\r\n    isEmpty() {\r\n        return this.value === null && this.children.isEmpty();\r\n    }\r\n    /**\r\n     * Given a path and predicate, return the first node and the path to that node\r\n     * where the predicate returns true.\r\n     *\r\n     * TODO Do a perf test -- If we're creating a bunch of `{path: value:}`\r\n     * objects on the way back out, it may be better to pass down a pathSoFar obj.\r\n     *\r\n     * @param relativePath - The remainder of the path\r\n     * @param predicate - The predicate to satisfy to return a node\r\n     */\r\n    findRootMostMatchingPathAndValue(relativePath, predicate) {\r\n        if (this.value != null && predicate(this.value)) {\r\n            return { path: newEmptyPath(), value: this.value };\r\n        }\r\n        else {\r\n            if (pathIsEmpty(relativePath)) {\r\n                return null;\r\n            }\r\n            else {\r\n                const front = pathGetFront(relativePath);\r\n                const child = this.children.get(front);\r\n                if (child !== null) {\r\n                    const childExistingPathAndValue = child.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);\r\n                    if (childExistingPathAndValue != null) {\r\n                        const fullPath = pathChild(new Path(front), childExistingPathAndValue.path);\r\n                        return { path: fullPath, value: childExistingPathAndValue.value };\r\n                    }\r\n                    else {\r\n                        return null;\r\n                    }\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Find, if it exists, the shortest subpath of the given path that points a defined\r\n     * value in the tree\r\n     */\r\n    findRootMostValueAndPath(relativePath) {\r\n        return this.findRootMostMatchingPathAndValue(relativePath, () => true);\r\n    }\r\n    /**\r\n     * @returns The subtree at the given path\r\n     */\r\n    subtree(relativePath) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            return this;\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const childTree = this.children.get(front);\r\n            if (childTree !== null) {\r\n                return childTree.subtree(pathPopFront(relativePath));\r\n            }\r\n            else {\r\n                return new ImmutableTree(null);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Sets a value at the specified path.\r\n     *\r\n     * @param relativePath - Path to set value at.\r\n     * @param toSet - Value to set.\r\n     * @returns Resulting tree.\r\n     */\r\n    set(relativePath, toSet) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            return new ImmutableTree(toSet, this.children);\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const child = this.children.get(front) || new ImmutableTree(null);\r\n            const newChild = child.set(pathPopFront(relativePath), toSet);\r\n            const newChildren = this.children.insert(front, newChild);\r\n            return new ImmutableTree(this.value, newChildren);\r\n        }\r\n    }\r\n    /**\r\n     * Removes the value at the specified path.\r\n     *\r\n     * @param relativePath - Path to value to remove.\r\n     * @returns Resulting tree.\r\n     */\r\n    remove(relativePath) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            if (this.children.isEmpty()) {\r\n                return new ImmutableTree(null);\r\n            }\r\n            else {\r\n                return new ImmutableTree(null, this.children);\r\n            }\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const child = this.children.get(front);\r\n            if (child) {\r\n                const newChild = child.remove(pathPopFront(relativePath));\r\n                let newChildren;\r\n                if (newChild.isEmpty()) {\r\n                    newChildren = this.children.remove(front);\r\n                }\r\n                else {\r\n                    newChildren = this.children.insert(front, newChild);\r\n                }\r\n                if (this.value === null && newChildren.isEmpty()) {\r\n                    return new ImmutableTree(null);\r\n                }\r\n                else {\r\n                    return new ImmutableTree(this.value, newChildren);\r\n                }\r\n            }\r\n            else {\r\n                return this;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Gets a value from the tree.\r\n     *\r\n     * @param relativePath - Path to get value for.\r\n     * @returns Value at path, or null.\r\n     */\r\n    get(relativePath) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            return this.value;\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const child = this.children.get(front);\r\n            if (child) {\r\n                return child.get(pathPopFront(relativePath));\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Replace the subtree at the specified path with the given new tree.\r\n     *\r\n     * @param relativePath - Path to replace subtree for.\r\n     * @param newTree - New tree.\r\n     * @returns Resulting tree.\r\n     */\r\n    setTree(relativePath, newTree) {\r\n        if (pathIsEmpty(relativePath)) {\r\n            return newTree;\r\n        }\r\n        else {\r\n            const front = pathGetFront(relativePath);\r\n            const child = this.children.get(front) || new ImmutableTree(null);\r\n            const newChild = child.setTree(pathPopFront(relativePath), newTree);\r\n            let newChildren;\r\n            if (newChild.isEmpty()) {\r\n                newChildren = this.children.remove(front);\r\n            }\r\n            else {\r\n                newChildren = this.children.insert(front, newChild);\r\n            }\r\n            return new ImmutableTree(this.value, newChildren);\r\n        }\r\n    }\r\n    /**\r\n     * Performs a depth first fold on this tree. Transforms a tree into a single\r\n     * value, given a function that operates on the path to a node, an optional\r\n     * current value, and a map of child names to folded subtrees\r\n     */\r\n    fold(fn) {\r\n        return this.fold_(newEmptyPath(), fn);\r\n    }\r\n    /**\r\n     * Recursive helper for public-facing fold() method\r\n     */\r\n    fold_(pathSoFar, fn) {\r\n        const accum = {};\r\n        this.children.inorderTraversal((childKey, childTree) => {\r\n            accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);\r\n        });\r\n        return fn(pathSoFar, this.value, accum);\r\n    }\r\n    /**\r\n     * Find the first matching value on the given path. Return the result of applying f to it.\r\n     */\r\n    findOnPath(path, f) {\r\n        return this.findOnPath_(path, newEmptyPath(), f);\r\n    }\r\n    findOnPath_(pathToFollow, pathSoFar, f) {\r\n        const result = this.value ? f(pathSoFar, this.value) : false;\r\n        if (result) {\r\n            return result;\r\n        }\r\n        else {\r\n            if (pathIsEmpty(pathToFollow)) {\r\n                return null;\r\n            }\r\n            else {\r\n                const front = pathGetFront(pathToFollow);\r\n                const nextChild = this.children.get(front);\r\n                if (nextChild) {\r\n                    return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);\r\n                }\r\n                else {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    foreachOnPath(path, f) {\r\n        return this.foreachOnPath_(path, newEmptyPath(), f);\r\n    }\r\n    foreachOnPath_(pathToFollow, currentRelativePath, f) {\r\n        if (pathIsEmpty(pathToFollow)) {\r\n            return this;\r\n        }\r\n        else {\r\n            if (this.value) {\r\n                f(currentRelativePath, this.value);\r\n            }\r\n            const front = pathGetFront(pathToFollow);\r\n            const nextChild = this.children.get(front);\r\n            if (nextChild) {\r\n                return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);\r\n            }\r\n            else {\r\n                return new ImmutableTree(null);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Calls the given function for each node in the tree that has a value.\r\n     *\r\n     * @param f - A function to be called with the path from the root of the tree to\r\n     * a node, and the value at that node. Called in depth-first order.\r\n     */\r\n    foreach(f) {\r\n        this.foreach_(newEmptyPath(), f);\r\n    }\r\n    foreach_(currentRelativePath, f) {\r\n        this.children.inorderTraversal((childName, childTree) => {\r\n            childTree.foreach_(pathChild(currentRelativePath, childName), f);\r\n        });\r\n        if (this.value) {\r\n            f(currentRelativePath, this.value);\r\n        }\r\n    }\r\n    foreachChild(f) {\r\n        this.children.inorderTraversal((childName, childTree) => {\r\n            if (childTree.value) {\r\n                f(childName, childTree.value);\r\n            }\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=ImmutableTree.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/Path.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/SortedMap.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/util.ts"],"map":"{\"version\":3,\"file\":\"ImmutableTree.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/core/util/ImmutableTree.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/core/util/ImmutableTree.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { Path } from './Path';\r\nimport { SortedMap } from './SortedMap';\r\n/**\r\n * A tree with immutable elements.\r\n */\r\nexport declare class ImmutableTree<T> {\r\n    readonly value: T | null;\r\n    readonly children: SortedMap<string, ImmutableTree<T>>;\r\n    static fromObject<T>(obj: {\r\n        [k: string]: T;\r\n    }): ImmutableTree<T>;\r\n    constructor(value: T | null, children?: SortedMap<string, ImmutableTree<T>>);\r\n    /**\r\n     * True if the value is empty and there are no children\r\n     */\r\n    isEmpty(): boolean;\r\n    /**\r\n     * Given a path and predicate, return the first node and the path to that node\r\n     * where the predicate returns true.\r\n     *\r\n     * TODO Do a perf test -- If we're creating a bunch of `{path: value:}`\r\n     * objects on the way back out, it may be better to pass down a pathSoFar obj.\r\n     *\r\n     * @param relativePath - The remainder of the path\r\n     * @param predicate - The predicate to satisfy to return a node\r\n     */\r\n    findRootMostMatchingPathAndValue(relativePath: Path, predicate: (a: T) => boolean): {\r\n        path: Path;\r\n        value: T;\r\n    } | null;\r\n    /**\r\n     * Find, if it exists, the shortest subpath of the given path that points a defined\r\n     * value in the tree\r\n     */\r\n    findRootMostValueAndPath(relativePath: Path): {\r\n        path: Path;\r\n        value: T;\r\n    } | null;\r\n    /**\r\n     * @returns The subtree at the given path\r\n     */\r\n    subtree(relativePath: Path): ImmutableTree<T>;\r\n    /**\r\n     * Sets a value at the specified path.\r\n     *\r\n     * @param relativePath - Path to set value at.\r\n     * @param toSet - Value to set.\r\n     * @returns Resulting tree.\r\n     */\r\n    set(relativePath: Path, toSet: T | null): ImmutableTree<T>;\r\n    /**\r\n     * Removes the value at the specified path.\r\n     *\r\n     * @param relativePath - Path to value to remove.\r\n     * @returns Resulting tree.\r\n     */\r\n    remove(relativePath: Path): ImmutableTree<T>;\r\n    /**\r\n     * Gets a value from the tree.\r\n     *\r\n     * @param relativePath - Path to get value for.\r\n     * @returns Value at path, or null.\r\n     */\r\n    get(relativePath: Path): T | null;\r\n    /**\r\n     * Replace the subtree at the specified path with the given new tree.\r\n     *\r\n     * @param relativePath - Path to replace subtree for.\r\n     * @param newTree - New tree.\r\n     * @returns Resulting tree.\r\n     */\r\n    setTree(relativePath: Path, newTree: ImmutableTree<T>): ImmutableTree<T>;\r\n    /**\r\n     * Performs a depth first fold on this tree. Transforms a tree into a single\r\n     * value, given a function that operates on the path to a node, an optional\r\n     * current value, and a map of child names to folded subtrees\r\n     */\r\n    fold<V>(fn: (path: Path, value: T, children: {\r\n        [k: string]: V;\r\n    }) => V): V;\r\n    /**\r\n     * Recursive helper for public-facing fold() method\r\n     */\r\n    private fold_;\r\n    /**\r\n     * Find the first matching value on the given path. Return the result of applying f to it.\r\n     */\r\n    findOnPath<V>(path: Path, f: (path: Path, value: T) => V | null): V | null;\r\n    private findOnPath_;\r\n    foreachOnPath(path: Path, f: (path: Path, value: T) => void): ImmutableTree<T>;\r\n    private foreachOnPath_;\r\n    /**\r\n     * Calls the given function for each node in the tree that has a value.\r\n     *\r\n     * @param f - A function to be called with the path from the root of the tree to\r\n     * a node, and the value at that node. Called in depth-first order.\r\n     */\r\n    foreach(f: (path: Path, value: T) => void): void;\r\n    private foreach_;\r\n    foreachChild(f: (name: string, value: T) => void): void;\r\n}\r\n"}}
