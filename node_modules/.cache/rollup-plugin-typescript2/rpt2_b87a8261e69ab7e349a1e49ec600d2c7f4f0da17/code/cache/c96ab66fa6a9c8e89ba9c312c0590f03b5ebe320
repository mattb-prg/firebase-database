{"code":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { assert, assertionError, safeGet } from '@firebase/util';\r\nimport { CompoundWrite, compoundWriteAddWrite, compoundWriteAddWrites, compoundWriteApply, compoundWriteChildCompoundWrite, compoundWriteGetCompleteChildren, compoundWriteGetCompleteNode, compoundWriteHasCompleteWrite, compoundWriteIsEmpty, compoundWriteRemoveWrite } from './CompoundWrite';\r\nimport { ChildrenNode } from './snap/ChildrenNode';\r\nimport { PRIORITY_INDEX } from './snap/indexes/PriorityIndex';\r\nimport { newEmptyPath, newRelativePath, Path, pathChild, pathContains, pathGetFront, pathIsEmpty, pathPopFront } from './util/Path';\r\nimport { each } from './util/util';\r\n/**\r\n * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\r\n *\r\n */\r\nexport function writeTreeChildWrites(writeTree, path) {\r\n    return newWriteTreeRef(path, writeTree);\r\n}\r\n/**\r\n * Record a new overwrite from user code.\r\n *\r\n * @param visible - This is set to false by some transactions. It should be excluded from event caches\r\n */\r\nexport function writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {\r\n    assert(writeId > writeTree.lastWriteId, 'Stacking an older write on top of newer ones');\r\n    if (visible === undefined) {\r\n        visible = true;\r\n    }\r\n    writeTree.allWrites.push({\r\n        path,\r\n        snap,\r\n        writeId,\r\n        visible\r\n    });\r\n    if (visible) {\r\n        writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);\r\n    }\r\n    writeTree.lastWriteId = writeId;\r\n}\r\n/**\r\n * Record a new merge from user code.\r\n */\r\nexport function writeTreeAddMerge(writeTree, path, changedChildren, writeId) {\r\n    assert(writeId > writeTree.lastWriteId, 'Stacking an older merge on top of newer ones');\r\n    writeTree.allWrites.push({\r\n        path,\r\n        children: changedChildren,\r\n        writeId,\r\n        visible: true\r\n    });\r\n    writeTree.visibleWrites = compoundWriteAddWrites(writeTree.visibleWrites, path, changedChildren);\r\n    writeTree.lastWriteId = writeId;\r\n}\r\nexport function writeTreeGetWrite(writeTree, writeId) {\r\n    for (let i = 0; i < writeTree.allWrites.length; i++) {\r\n        const record = writeTree.allWrites[i];\r\n        if (record.writeId === writeId) {\r\n            return record;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\r\n * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\r\n *\r\n * @returns true if the write may have been visible (meaning we'll need to reevaluate / raise\r\n * events as a result).\r\n */\r\nexport function writeTreeRemoveWrite(writeTree, writeId) {\r\n    // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied\r\n    // out of order.\r\n    //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;\r\n    //assert(validClear, \"Either we don't have this write, or it's the first one in the queue\");\r\n    const idx = writeTree.allWrites.findIndex(s => {\r\n        return s.writeId === writeId;\r\n    });\r\n    assert(idx >= 0, 'removeWrite called with nonexistent writeId.');\r\n    const writeToRemove = writeTree.allWrites[idx];\r\n    writeTree.allWrites.splice(idx, 1);\r\n    let removedWriteWasVisible = writeToRemove.visible;\r\n    let removedWriteOverlapsWithOtherWrites = false;\r\n    let i = writeTree.allWrites.length - 1;\r\n    while (removedWriteWasVisible && i >= 0) {\r\n        const currentWrite = writeTree.allWrites[i];\r\n        if (currentWrite.visible) {\r\n            if (i >= idx &&\r\n                writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {\r\n                // The removed write was completely shadowed by a subsequent write.\r\n                removedWriteWasVisible = false;\r\n            }\r\n            else if (pathContains(writeToRemove.path, currentWrite.path)) {\r\n                // Either we're covering some writes or they're covering part of us (depending on which came first).\r\n                removedWriteOverlapsWithOtherWrites = true;\r\n            }\r\n        }\r\n        i--;\r\n    }\r\n    if (!removedWriteWasVisible) {\r\n        return false;\r\n    }\r\n    else if (removedWriteOverlapsWithOtherWrites) {\r\n        // There's some shadowing going on. Just rebuild the visible writes from scratch.\r\n        writeTreeResetTree_(writeTree);\r\n        return true;\r\n    }\r\n    else {\r\n        // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.\r\n        if (writeToRemove.snap) {\r\n            writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);\r\n        }\r\n        else {\r\n            const children = writeToRemove.children;\r\n            each(children, (childName) => {\r\n                writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));\r\n            });\r\n        }\r\n        return true;\r\n    }\r\n}\r\nfunction writeTreeRecordContainsPath_(writeRecord, path) {\r\n    if (writeRecord.snap) {\r\n        return pathContains(writeRecord.path, path);\r\n    }\r\n    else {\r\n        for (const childName in writeRecord.children) {\r\n            if (writeRecord.children.hasOwnProperty(childName) &&\r\n                pathContains(pathChild(writeRecord.path, childName), path)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots\r\n */\r\nfunction writeTreeResetTree_(writeTree) {\r\n    writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());\r\n    if (writeTree.allWrites.length > 0) {\r\n        writeTree.lastWriteId =\r\n            writeTree.allWrites[writeTree.allWrites.length - 1].writeId;\r\n    }\r\n    else {\r\n        writeTree.lastWriteId = -1;\r\n    }\r\n}\r\n/**\r\n * The default filter used when constructing the tree. Keep everything that's visible.\r\n */\r\nfunction writeTreeDefaultFilter_(write) {\r\n    return write.visible;\r\n}\r\n/**\r\n * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of\r\n * event data at that path.\r\n */\r\nfunction writeTreeLayerTree_(writes, filter, treeRoot) {\r\n    let compoundWrite = CompoundWrite.empty();\r\n    for (let i = 0; i < writes.length; ++i) {\r\n        const write = writes[i];\r\n        // Theory, a later set will either:\r\n        // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction\r\n        // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction\r\n        if (filter(write)) {\r\n            const writePath = write.path;\r\n            let relativePath;\r\n            if (write.snap) {\r\n                if (pathContains(treeRoot, writePath)) {\r\n                    relativePath = newRelativePath(treeRoot, writePath);\r\n                    compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write.snap);\r\n                }\r\n                else if (pathContains(writePath, treeRoot)) {\r\n                    relativePath = newRelativePath(writePath, treeRoot);\r\n                    compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write.snap.getChild(relativePath));\r\n                }\r\n                else {\r\n                    // There is no overlap between root path and write path, ignore write\r\n                }\r\n            }\r\n            else if (write.children) {\r\n                if (pathContains(treeRoot, writePath)) {\r\n                    relativePath = newRelativePath(treeRoot, writePath);\r\n                    compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write.children);\r\n                }\r\n                else if (pathContains(writePath, treeRoot)) {\r\n                    relativePath = newRelativePath(writePath, treeRoot);\r\n                    if (pathIsEmpty(relativePath)) {\r\n                        compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write.children);\r\n                    }\r\n                    else {\r\n                        const child = safeGet(write.children, pathGetFront(relativePath));\r\n                        if (child) {\r\n                            // There exists a child in this node that matches the root path\r\n                            const deepNode = child.getChild(pathPopFront(relativePath));\r\n                            compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // There is no overlap between root path and write path, ignore write\r\n                }\r\n            }\r\n            else {\r\n                throw assertionError('WriteRecord should have .snap or .children');\r\n            }\r\n        }\r\n    }\r\n    return compoundWrite;\r\n}\r\n/**\r\n * Return a complete snapshot for the given path if there's visible write data at that path, else null.\r\n * No server data is considered.\r\n *\r\n */\r\nexport function writeTreeGetCompleteWriteData(writeTree, path) {\r\n    return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);\r\n}\r\n/**\r\n * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\r\n * writes), attempt to calculate a complete snapshot for the given path\r\n *\r\n * @param writeIdsToExclude - An optional set to be excluded\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */\r\nexport function writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\r\n    if (!writeIdsToExclude && !includeHiddenWrites) {\r\n        const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);\r\n        if (shadowingNode != null) {\r\n            return shadowingNode;\r\n        }\r\n        else {\r\n            const subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n            if (compoundWriteIsEmpty(subMerge)) {\r\n                return completeServerCache;\r\n            }\r\n            else if (completeServerCache == null &&\r\n                !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {\r\n                // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow\r\n                return null;\r\n            }\r\n            else {\r\n                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\r\n                return compoundWriteApply(subMerge, layeredCache);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n        if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {\r\n            return completeServerCache;\r\n        }\r\n        else {\r\n            // If the server cache is null, and we don't have a complete cache, we need to return null\r\n            if (!includeHiddenWrites &&\r\n                completeServerCache == null &&\r\n                !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {\r\n                return null;\r\n            }\r\n            else {\r\n                const filter = function (write) {\r\n                    return ((write.visible || includeHiddenWrites) &&\r\n                        (!writeIdsToExclude ||\r\n                            !~writeIdsToExclude.indexOf(write.writeId)) &&\r\n                        (pathContains(write.path, treePath) ||\r\n                            pathContains(treePath, write.path)));\r\n                };\r\n                const mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);\r\n                const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;\r\n                return compoundWriteApply(mergeAtPath, layeredCache);\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\r\n * Used when creating new views, to pre-fill their complete event children snapshot.\r\n */\r\nexport function writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {\r\n    let completeChildren = ChildrenNode.EMPTY_NODE;\r\n    const topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);\r\n    if (topLevelSet) {\r\n        if (!topLevelSet.isLeafNode()) {\r\n            // we're shadowing everything. Return the children.\r\n            topLevelSet.forEachChild(PRIORITY_INDEX, (childName, childSnap) => {\r\n                completeChildren = completeChildren.updateImmediateChild(childName, childSnap);\r\n            });\r\n        }\r\n        return completeChildren;\r\n    }\r\n    else if (completeServerChildren) {\r\n        // Layer any children we have on top of this\r\n        // We know we don't have a top-level set, so just enumerate existing children\r\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n        completeServerChildren.forEachChild(PRIORITY_INDEX, (childName, childNode) => {\r\n            const node = compoundWriteApply(compoundWriteChildCompoundWrite(merge, new Path(childName)), childNode);\r\n            completeChildren = completeChildren.updateImmediateChild(childName, node);\r\n        });\r\n        // Add any complete children we have from the set\r\n        compoundWriteGetCompleteChildren(merge).forEach(namedNode => {\r\n            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\r\n        });\r\n        return completeChildren;\r\n    }\r\n    else {\r\n        // We don't have anything to layer on top of. Layer on any children we have\r\n        // Note that we can return an empty snap if we have a defined delete\r\n        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n        compoundWriteGetCompleteChildren(merge).forEach(namedNode => {\r\n            completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);\r\n        });\r\n        return completeChildren;\r\n    }\r\n}\r\n/**\r\n * Given that the underlying server data has updated, determine what, if anything, needs to be\r\n * applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist\r\n */\r\nexport function writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {\r\n    assert(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');\r\n    const path = pathChild(treePath, childPath);\r\n    if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {\r\n        // At this point we can probably guarantee that we're in case 2, meaning no events\r\n        // May need to check visibility while doing the findRootMostValueAndPath call\r\n        return null;\r\n    }\r\n    else {\r\n        // No complete shadowing. We're either partially shadowing or not shadowing at all.\r\n        const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);\r\n        if (compoundWriteIsEmpty(childMerge)) {\r\n            // We're not shadowing at all. Case 1\r\n            return existingServerSnap.getChild(childPath);\r\n        }\r\n        else {\r\n            // This could be more efficient if the serverNode + updates doesn't change the eventSnap\r\n            // However this is tricky to find out, since user updates don't necessary change the server\r\n            // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server\r\n            // adds nodes, but doesn't change any existing writes. It is therefore not enough to\r\n            // only check if the updates change the serverNode.\r\n            // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?\r\n            return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */\r\nexport function writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {\r\n    const path = pathChild(treePath, childKey);\r\n    const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);\r\n    if (shadowingNode != null) {\r\n        return shadowingNode;\r\n    }\r\n    else {\r\n        if (existingServerSnap.isCompleteForChild(childKey)) {\r\n            const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);\r\n            return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n */\r\nexport function writeTreeShadowingWrite(writeTree, path) {\r\n    return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);\r\n}\r\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window.\r\n */\r\nexport function writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index) {\r\n    let toIterate;\r\n    const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);\r\n    const shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());\r\n    if (shadowingNode != null) {\r\n        toIterate = shadowingNode;\r\n    }\r\n    else if (completeServerData != null) {\r\n        toIterate = compoundWriteApply(merge, completeServerData);\r\n    }\r\n    else {\r\n        // no children to iterate on\r\n        return [];\r\n    }\r\n    toIterate = toIterate.withIndex(index);\r\n    if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {\r\n        const nodes = [];\r\n        const cmp = index.getCompare();\r\n        const iter = reverse\r\n            ? toIterate.getReverseIteratorFrom(startPost, index)\r\n            : toIterate.getIteratorFrom(startPost, index);\r\n        let next = iter.getNext();\r\n        while (next && nodes.length < count) {\r\n            if (cmp(next, startPost) !== 0) {\r\n                nodes.push(next);\r\n            }\r\n            next = iter.getNext();\r\n        }\r\n        return nodes;\r\n    }\r\n    else {\r\n        return [];\r\n    }\r\n}\r\nexport function newWriteTree() {\r\n    return {\r\n        visibleWrites: CompoundWrite.empty(),\r\n        allWrites: [],\r\n        lastWriteId: -1\r\n    };\r\n}\r\n/**\r\n * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\r\n * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\r\n * can lead to a more expensive calculation.\r\n *\r\n * @param writeIdsToExclude - Optional writes to exclude.\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */\r\nexport function writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {\r\n    return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);\r\n}\r\n/**\r\n * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\r\n * mix of the given server data and write data.\r\n *\r\n */\r\nexport function writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {\r\n    return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);\r\n}\r\n/**\r\n * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\r\n * if anything, needs to be applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events should be raised\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\r\n *\r\n *\r\n */\r\nexport function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {\r\n    return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);\r\n}\r\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n *\r\n */\r\nexport function writeTreeRefShadowingWrite(writeTreeRef, path) {\r\n    return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));\r\n}\r\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window\r\n */\r\nexport function writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index) {\r\n    return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);\r\n}\r\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */\r\nexport function writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {\r\n    return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);\r\n}\r\n/**\r\n * Return a WriteTreeRef for a child.\r\n */\r\nexport function writeTreeRefChild(writeTreeRef, childName) {\r\n    return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);\r\n}\r\nexport function newWriteTreeRef(path, writeTree) {\r\n    return {\r\n        treePath: path,\r\n        writeTree\r\n    };\r\n}\r\n//# sourceMappingURL=WriteTree.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/util/dist/index.d.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/CompoundWrite.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/snap/ChildrenNode.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/snap/indexes/Index.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/snap/indexes/PriorityIndex.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/snap/Node.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/Path.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/util.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/view/CacheNode.ts"],"map":"{\"version\":3,\"file\":\"WriteTree.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/core/WriteTree.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/core/WriteTree.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { CompoundWrite } from './CompoundWrite';\r\nimport { ChildrenNode } from './snap/ChildrenNode';\r\nimport { Index } from './snap/indexes/Index';\r\nimport { NamedNode, Node } from './snap/Node';\r\nimport { Path } from './util/Path';\r\nimport { CacheNode } from './view/CacheNode';\r\n/**\r\n * Defines a single user-initiated write operation. May be the result of a set(), transaction(), or update() call. In\r\n * the case of a set() or transaction, snap wil be non-null.  In the case of an update(), children will be non-null.\r\n */\r\nexport interface WriteRecord {\r\n    writeId: number;\r\n    path: Path;\r\n    snap?: Node | null;\r\n    children?: {\r\n        [k: string]: Node;\r\n    } | null;\r\n    visible: boolean;\r\n}\r\n/**\r\n * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.\r\n *\r\n */\r\nexport declare function writeTreeChildWrites(writeTree: WriteTree, path: Path): WriteTreeRef;\r\n/**\r\n * Record a new overwrite from user code.\r\n *\r\n * @param visible - This is set to false by some transactions. It should be excluded from event caches\r\n */\r\nexport declare function writeTreeAddOverwrite(writeTree: WriteTree, path: Path, snap: Node, writeId: number, visible?: boolean): void;\r\n/**\r\n * Record a new merge from user code.\r\n */\r\nexport declare function writeTreeAddMerge(writeTree: WriteTree, path: Path, changedChildren: {\r\n    [k: string]: Node;\r\n}, writeId: number): void;\r\nexport declare function writeTreeGetWrite(writeTree: WriteTree, writeId: number): WriteRecord | null;\r\n/**\r\n * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates\r\n * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.\r\n *\r\n * @returns true if the write may have been visible (meaning we'll need to reevaluate / raise\r\n * events as a result).\r\n */\r\nexport declare function writeTreeRemoveWrite(writeTree: WriteTree, writeId: number): boolean;\r\n/**\r\n * Return a complete snapshot for the given path if there's visible write data at that path, else null.\r\n * No server data is considered.\r\n *\r\n */\r\nexport declare function writeTreeGetCompleteWriteData(writeTree: WriteTree, path: Path): Node | null;\r\n/**\r\n * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden\r\n * writes), attempt to calculate a complete snapshot for the given path\r\n *\r\n * @param writeIdsToExclude - An optional set to be excluded\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */\r\nexport declare function writeTreeCalcCompleteEventCache(writeTree: WriteTree, treePath: Path, completeServerCache: Node | null, writeIdsToExclude?: number[], includeHiddenWrites?: boolean): Node | null;\r\n/**\r\n * With optional, underlying server data, attempt to return a children node of children that we have complete data for.\r\n * Used when creating new views, to pre-fill their complete event children snapshot.\r\n */\r\nexport declare function writeTreeCalcCompleteEventChildren(writeTree: WriteTree, treePath: Path, completeServerChildren: ChildrenNode | null): Node;\r\n/**\r\n * Given that the underlying server data has updated, determine what, if anything, needs to be\r\n * applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist\r\n */\r\nexport declare function writeTreeCalcEventCacheAfterServerOverwrite(writeTree: WriteTree, treePath: Path, childPath: Path, existingEventSnap: Node | null, existingServerSnap: Node | null): Node | null;\r\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */\r\nexport declare function writeTreeCalcCompleteChild(writeTree: WriteTree, treePath: Path, childKey: string, existingServerSnap: CacheNode): Node | null;\r\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n */\r\nexport declare function writeTreeShadowingWrite(writeTree: WriteTree, path: Path): Node | null;\r\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window.\r\n */\r\nexport declare function writeTreeCalcIndexedSlice(writeTree: WriteTree, treePath: Path, completeServerData: Node | null, startPost: NamedNode, count: number, reverse: boolean, index: Index): NamedNode[];\r\nexport declare function newWriteTree(): WriteTree;\r\n/**\r\n * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them\r\n * with underlying server data (to create \"event cache\" data).  Pending writes are added with addOverwrite()\r\n * and addMerge(), and removed with removeWrite().\r\n */\r\nexport interface WriteTree {\r\n    /**\r\n     * A tree tracking the result of applying all visible writes.  This does not include transactions with\r\n     * applyLocally=false or writes that are completely shadowed by other writes.\r\n     */\r\n    visibleWrites: CompoundWrite;\r\n    /**\r\n     * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary\r\n     * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also\r\n     * used by transactions).\r\n     */\r\n    allWrites: WriteRecord[];\r\n    lastWriteId: number;\r\n}\r\n/**\r\n * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used\r\n * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node\r\n * can lead to a more expensive calculation.\r\n *\r\n * @param writeIdsToExclude - Optional writes to exclude.\r\n * @param includeHiddenWrites - Defaults to false, whether or not to layer on writes with visible set to false\r\n */\r\nexport declare function writeTreeRefCalcCompleteEventCache(writeTreeRef: WriteTreeRef, completeServerCache: Node | null, writeIdsToExclude?: number[], includeHiddenWrites?: boolean): Node | null;\r\n/**\r\n * If possible, returns a children node containing all of the complete children we have data for. The returned data is a\r\n * mix of the given server data and write data.\r\n *\r\n */\r\nexport declare function writeTreeRefCalcCompleteEventChildren(writeTreeRef: WriteTreeRef, completeServerChildren: ChildrenNode | null): ChildrenNode;\r\n/**\r\n * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,\r\n * if anything, needs to be applied to the event cache.\r\n *\r\n * Possibilities:\r\n *\r\n * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data\r\n *\r\n * 2. Some write is completely shadowing. No events to be raised\r\n *\r\n * 3. Is partially shadowed. Events should be raised\r\n *\r\n * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert\r\n *\r\n *\r\n */\r\nexport declare function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef: WriteTreeRef, path: Path, existingEventSnap: Node | null, existingServerSnap: Node | null): Node | null;\r\n/**\r\n * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at\r\n * a higher path, this will return the child of that write relative to the write and this path.\r\n * Returns null if there is no write at this path.\r\n *\r\n */\r\nexport declare function writeTreeRefShadowingWrite(writeTreeRef: WriteTreeRef, path: Path): Node | null;\r\n/**\r\n * This method is used when processing child remove events on a query. If we can, we pull in children that were outside\r\n * the window, but may now be in the window\r\n */\r\nexport declare function writeTreeRefCalcIndexedSlice(writeTreeRef: WriteTreeRef, completeServerData: Node | null, startPost: NamedNode, count: number, reverse: boolean, index: Index): NamedNode[];\r\n/**\r\n * Returns a complete child for a given server snap after applying all user writes or null if there is no\r\n * complete child for this ChildKey.\r\n */\r\nexport declare function writeTreeRefCalcCompleteChild(writeTreeRef: WriteTreeRef, childKey: string, existingServerCache: CacheNode): Node | null;\r\n/**\r\n * Return a WriteTreeRef for a child.\r\n */\r\nexport declare function writeTreeRefChild(writeTreeRef: WriteTreeRef, childName: string): WriteTreeRef;\r\nexport declare function newWriteTreeRef(path: Path, writeTree: WriteTree): WriteTreeRef;\r\n/**\r\n * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods\r\n * just proxy to the underlying WriteTree.\r\n *\r\n */\r\nexport interface WriteTreeRef {\r\n    /**\r\n     * The path to this particular write tree ref. Used for calling methods on writeTree_ while exposing a simpler\r\n     * interface to callers.\r\n     */\r\n    readonly treePath: Path;\r\n    /**\r\n     * * A reference to the actual tree of write data. All methods are pass-through to the tree, but with the appropriate\r\n     * path prefixed.\r\n     *\r\n     * This lets us make cheap references to points in the tree for sync points without having to copy and maintain all of\r\n     * the data.\r\n     */\r\n    readonly writeTree: WriteTree;\r\n}\r\n"}}
