{"code":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { base64Encode, isNodeSdk, stringify } from '@firebase/util';\r\nimport { repoInfoConnectionURL } from '../core/RepoInfo';\r\nimport { statsManagerGetCollection } from '../core/stats/StatsManager';\r\nimport { executeWhenDOMReady, isChromeExtensionContentScript, isWindowsStoreApp, log, logWrapper, LUIDGenerator, splitStringBySize } from '../core/util/util';\r\nimport { APP_CHECK_TOKEN_PARAM, APPLICATION_ID_PARAM, FORGE_DOMAIN_RE, FORGE_REF, LAST_SESSION_PARAM, LONG_POLLING, PROTOCOL_VERSION, REFERER_PARAM, TRANSPORT_SESSION_PARAM, VERSION_PARAM } from './Constants';\r\nimport { PacketReceiver } from './polling/PacketReceiver';\r\n// URL query parameters associated with longpolling\r\nexport const FIREBASE_LONGPOLL_START_PARAM = 'start';\r\nexport const FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';\r\nexport const FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';\r\nexport const FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';\r\nexport const FIREBASE_LONGPOLL_ID_PARAM = 'id';\r\nexport const FIREBASE_LONGPOLL_PW_PARAM = 'pw';\r\nexport const FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';\r\nexport const FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';\r\nexport const FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';\r\nexport const FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';\r\nexport const FIREBASE_LONGPOLL_DATA_PARAM = 'd';\r\nexport const FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM = 'disconn';\r\nexport const FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';\r\n//Data size constants.\r\n//TODO: Perf: the maximum length actually differs from browser to browser.\r\n// We should check what browser we're on and set accordingly.\r\nconst MAX_URL_DATA_SIZE = 1870;\r\nconst SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=\r\nconst MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;\r\n/**\r\n * Keepalive period\r\n * send a fresh request at minimum every 25 seconds. Opera has a maximum request\r\n * length of 30 seconds that we can't exceed.\r\n */\r\nconst KEEPALIVE_REQUEST_INTERVAL = 25000;\r\n/**\r\n * How long to wait before aborting a long-polling connection attempt.\r\n */\r\nconst LP_CONNECT_TIMEOUT = 30000;\r\n/**\r\n * This class manages a single long-polling connection.\r\n */\r\nexport class BrowserPollConnection {\r\n    /**\r\n     * @param connId An identifier for this connection, used for logging\r\n     * @param repoInfo The info for the endpoint to send data to.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The AppCheck token for this client.\r\n     * @param authToken The AuthToken to use for this connection.\r\n     * @param transportSessionId Optional transportSessionid if we are\r\n     * reconnecting for an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if the PersistentConnection has\r\n     * already created a connection previously\r\n     */\r\n    constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {\r\n        this.connId = connId;\r\n        this.repoInfo = repoInfo;\r\n        this.applicationId = applicationId;\r\n        this.appCheckToken = appCheckToken;\r\n        this.authToken = authToken;\r\n        this.transportSessionId = transportSessionId;\r\n        this.lastSessionId = lastSessionId;\r\n        this.bytesSent = 0;\r\n        this.bytesReceived = 0;\r\n        this.everConnected_ = false;\r\n        this.log_ = logWrapper(connId);\r\n        this.stats_ = statsManagerGetCollection(repoInfo);\r\n        this.urlFn = (params) => {\r\n            // Always add the token if we have one.\r\n            if (this.appCheckToken) {\r\n                params[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;\r\n            }\r\n            return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);\r\n        };\r\n    }\r\n    /**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */\r\n    open(onMessage, onDisconnect) {\r\n        this.curSegmentNum = 0;\r\n        this.onDisconnect_ = onDisconnect;\r\n        this.myPacketOrderer = new PacketReceiver(onMessage);\r\n        this.isClosed_ = false;\r\n        this.connectTimeoutTimer_ = setTimeout(() => {\r\n            this.log_('Timed out trying to connect.');\r\n            // Make sure we clear the host cache\r\n            this.onClosed_();\r\n            this.connectTimeoutTimer_ = null;\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }, Math.floor(LP_CONNECT_TIMEOUT));\r\n        // Ensure we delay the creation of the iframe until the DOM is loaded.\r\n        executeWhenDOMReady(() => {\r\n            if (this.isClosed_) {\r\n                return;\r\n            }\r\n            //Set up a callback that gets triggered once a connection is set up.\r\n            this.scriptTagHolder = new FirebaseIFrameScriptHolder((...args) => {\r\n                const [command, arg1, arg2, arg3, arg4] = args;\r\n                this.incrementIncomingBytes_(args);\r\n                if (!this.scriptTagHolder) {\r\n                    return; // we closed the connection.\r\n                }\r\n                if (this.connectTimeoutTimer_) {\r\n                    clearTimeout(this.connectTimeoutTimer_);\r\n                    this.connectTimeoutTimer_ = null;\r\n                }\r\n                this.everConnected_ = true;\r\n                if (command === FIREBASE_LONGPOLL_START_PARAM) {\r\n                    this.id = arg1;\r\n                    this.password = arg2;\r\n                }\r\n                else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {\r\n                    // Don't clear the host cache. We got a response from the server, so we know it's reachable\r\n                    if (arg1) {\r\n                        // We aren't expecting any more data (other than what the server's already in the process of sending us\r\n                        // through our already open polls), so don't send any more.\r\n                        this.scriptTagHolder.sendNewPolls = false;\r\n                        // arg1 in this case is the last response number sent by the server. We should try to receive\r\n                        // all of the responses up to this one before closing\r\n                        this.myPacketOrderer.closeAfter(arg1, () => {\r\n                            this.onClosed_();\r\n                        });\r\n                    }\r\n                    else {\r\n                        this.onClosed_();\r\n                    }\r\n                }\r\n                else {\r\n                    throw new Error('Unrecognized command received: ' + command);\r\n                }\r\n            }, (...args) => {\r\n                const [pN, data] = args;\r\n                this.incrementIncomingBytes_(args);\r\n                this.myPacketOrderer.handleResponse(pN, data);\r\n            }, () => {\r\n                this.onClosed_();\r\n            }, this.urlFn);\r\n            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results\r\n            //from cache.\r\n            const urlParams = {};\r\n            urlParams[FIREBASE_LONGPOLL_START_PARAM] = 't';\r\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);\r\n            if (this.scriptTagHolder.uniqueCallbackIdentifier) {\r\n                urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] =\r\n                    this.scriptTagHolder.uniqueCallbackIdentifier;\r\n            }\r\n            urlParams[VERSION_PARAM] = PROTOCOL_VERSION;\r\n            if (this.transportSessionId) {\r\n                urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;\r\n            }\r\n            if (this.lastSessionId) {\r\n                urlParams[LAST_SESSION_PARAM] = this.lastSessionId;\r\n            }\r\n            if (this.applicationId) {\r\n                urlParams[APPLICATION_ID_PARAM] = this.applicationId;\r\n            }\r\n            if (this.appCheckToken) {\r\n                urlParams[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;\r\n            }\r\n            if (typeof location !== 'undefined' &&\r\n                location.hostname &&\r\n                FORGE_DOMAIN_RE.test(location.hostname)) {\r\n                urlParams[REFERER_PARAM] = FORGE_REF;\r\n            }\r\n            const connectURL = this.urlFn(urlParams);\r\n            this.log_('Connecting via long-poll to ' + connectURL);\r\n            this.scriptTagHolder.addTag(connectURL, () => {\r\n                /* do nothing */\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Call this when a handshake has completed successfully and we want to consider the connection established\r\n     */\r\n    start() {\r\n        this.scriptTagHolder.startLongPoll(this.id, this.password);\r\n        this.addDisconnectPingFrame(this.id, this.password);\r\n    }\r\n    /**\r\n     * Forces long polling to be considered as a potential transport\r\n     */\r\n    static forceAllow() {\r\n        BrowserPollConnection.forceAllow_ = true;\r\n    }\r\n    /**\r\n     * Forces longpolling to not be considered as a potential transport\r\n     */\r\n    static forceDisallow() {\r\n        BrowserPollConnection.forceDisallow_ = true;\r\n    }\r\n    // Static method, use string literal so it can be accessed in a generic way\r\n    static isAvailable() {\r\n        if (isNodeSdk()) {\r\n            return false;\r\n        }\r\n        else if (BrowserPollConnection.forceAllow_) {\r\n            return true;\r\n        }\r\n        else {\r\n            // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in\r\n            // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).\r\n            return (!BrowserPollConnection.forceDisallow_ &&\r\n                typeof document !== 'undefined' &&\r\n                document.createElement != null &&\r\n                !isChromeExtensionContentScript() &&\r\n                !isWindowsStoreApp());\r\n        }\r\n    }\r\n    /**\r\n     * No-op for polling\r\n     */\r\n    markConnectionHealthy() { }\r\n    /**\r\n     * Stops polling and cleans up the iframe\r\n     */\r\n    shutdown_() {\r\n        this.isClosed_ = true;\r\n        if (this.scriptTagHolder) {\r\n            this.scriptTagHolder.close();\r\n            this.scriptTagHolder = null;\r\n        }\r\n        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.\r\n        if (this.myDisconnFrame) {\r\n            document.body.removeChild(this.myDisconnFrame);\r\n            this.myDisconnFrame = null;\r\n        }\r\n        if (this.connectTimeoutTimer_) {\r\n            clearTimeout(this.connectTimeoutTimer_);\r\n            this.connectTimeoutTimer_ = null;\r\n        }\r\n    }\r\n    /**\r\n     * Triggered when this transport is closed\r\n     */\r\n    onClosed_() {\r\n        if (!this.isClosed_) {\r\n            this.log_('Longpoll is closing itself');\r\n            this.shutdown_();\r\n            if (this.onDisconnect_) {\r\n                this.onDisconnect_(this.everConnected_);\r\n                this.onDisconnect_ = null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\r\n     * that we've left.\r\n     */\r\n    close() {\r\n        if (!this.isClosed_) {\r\n            this.log_('Longpoll is being closed.');\r\n            this.shutdown_();\r\n        }\r\n    }\r\n    /**\r\n     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\r\n     * broken into chunks (since URLs have a small maximum length).\r\n     * @param data - The JSON data to transmit.\r\n     */\r\n    send(data) {\r\n        const dataStr = stringify(data);\r\n        this.bytesSent += dataStr.length;\r\n        this.stats_.incrementCounter('bytes_sent', dataStr.length);\r\n        //first, lets get the base64-encoded data\r\n        const base64data = base64Encode(dataStr);\r\n        //We can only fit a certain amount in each URL, so we need to split this request\r\n        //up into multiple pieces if it doesn't fit in one request.\r\n        const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);\r\n        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number\r\n        //of segments so that we can reassemble the packet on the server.\r\n        for (let i = 0; i < dataSegs.length; i++) {\r\n            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);\r\n            this.curSegmentNum++;\r\n        }\r\n    }\r\n    /**\r\n     * This is how we notify the server that we're leaving.\r\n     * We aren't able to send requests with DHTML on a window close event, but we can\r\n     * trigger XHR requests in some browsers (everything but Opera basically).\r\n     */\r\n    addDisconnectPingFrame(id, pw) {\r\n        if (isNodeSdk()) {\r\n            return;\r\n        }\r\n        this.myDisconnFrame = document.createElement('iframe');\r\n        const urlParams = {};\r\n        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';\r\n        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;\r\n        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;\r\n        this.myDisconnFrame.src = this.urlFn(urlParams);\r\n        this.myDisconnFrame.style.display = 'none';\r\n        document.body.appendChild(this.myDisconnFrame);\r\n    }\r\n    /**\r\n     * Used to track the bytes received by this client\r\n     */\r\n    incrementIncomingBytes_(args) {\r\n        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.\r\n        const bytesReceived = stringify(args).length;\r\n        this.bytesReceived += bytesReceived;\r\n        this.stats_.incrementCounter('bytes_received', bytesReceived);\r\n    }\r\n}\r\n/*********************************************************************************************\r\n * A wrapper around an iframe that is used as a long-polling script holder.\r\n *********************************************************************************************/\r\nexport class FirebaseIFrameScriptHolder {\r\n    /**\r\n     * @param commandCB - The callback to be called when control commands are recevied from the server.\r\n     * @param onMessageCB - The callback to be triggered when responses arrive from the server.\r\n     * @param onDisconnect - The callback to be triggered when this tag holder is closed\r\n     * @param urlFn - A function that provides the URL of the endpoint to send data to.\r\n     */\r\n    constructor(commandCB, onMessageCB, onDisconnect, urlFn) {\r\n        this.onDisconnect = onDisconnect;\r\n        this.urlFn = urlFn;\r\n        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause\r\n        //problems in some browsers.\r\n        this.outstandingRequests = new Set();\r\n        //A queue of the pending segments waiting for transmission to the server.\r\n        this.pendingSegs = [];\r\n        //A serial number. We use this for two things:\r\n        // 1) A way to ensure the browser doesn't cache responses to polls\r\n        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The\r\n        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute\r\n        //    JSONP code in the order it was added to the iframe.\r\n        this.currentSerial = Math.floor(Math.random() * 100000000);\r\n        // This gets set to false when we're \"closing down\" the connection (e.g. we're switching transports but there's still\r\n        // incoming data from the server that we're waiting for).\r\n        this.sendNewPolls = true;\r\n        if (!isNodeSdk()) {\r\n            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the\r\n            //iframes where we put the long-polling script tags. We have two callbacks:\r\n            //   1) Command Callback - Triggered for control issues, like starting a connection.\r\n            //   2) Message Callback - Triggered when new data arrives.\r\n            this.uniqueCallbackIdentifier = LUIDGenerator();\r\n            window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;\r\n            window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] =\r\n                onMessageCB;\r\n            //Create an iframe for us to add script tags to.\r\n            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();\r\n            // Set the iframe's contents.\r\n            let script = '';\r\n            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient\r\n            // for ie9, but ie8 needs to do it again in the document itself.\r\n            if (this.myIFrame.src &&\r\n                this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:') {\r\n                const currentDomain = document.domain;\r\n                script = '<script>document.domain=\"' + currentDomain + '\";</script>';\r\n            }\r\n            const iframeContents = '<html><body>' + script + '</body></html>';\r\n            try {\r\n                this.myIFrame.doc.open();\r\n                this.myIFrame.doc.write(iframeContents);\r\n                this.myIFrame.doc.close();\r\n            }\r\n            catch (e) {\r\n                log('frame writing exception');\r\n                if (e.stack) {\r\n                    log(e.stack);\r\n                }\r\n                log(e);\r\n            }\r\n        }\r\n        else {\r\n            this.commandCB = commandCB;\r\n            this.onMessageCB = onMessageCB;\r\n        }\r\n    }\r\n    /**\r\n     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\r\n     * actually use.\r\n     */\r\n    static createIFrame_() {\r\n        const iframe = document.createElement('iframe');\r\n        iframe.style.display = 'none';\r\n        // This is necessary in order to initialize the document inside the iframe\r\n        if (document.body) {\r\n            document.body.appendChild(iframe);\r\n            try {\r\n                // If document.domain has been modified in IE, this will throw an error, and we need to set the\r\n                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute\r\n                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.\r\n                const a = iframe.contentWindow.document;\r\n                if (!a) {\r\n                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.\r\n                    log('No IE domain setting required');\r\n                }\r\n            }\r\n            catch (e) {\r\n                const domain = document.domain;\r\n                iframe.src =\r\n                    \"javascript:void((function(){document.open();document.domain='\" +\r\n                        domain +\r\n                        \"';document.close();})())\";\r\n            }\r\n        }\r\n        else {\r\n            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this\r\n            // never gets hit.\r\n            throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';\r\n        }\r\n        // Get the document of the iframe in a browser-specific way.\r\n        if (iframe.contentDocument) {\r\n            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari\r\n        }\r\n        else if (iframe.contentWindow) {\r\n            iframe.doc = iframe.contentWindow.document; // Internet Explorer\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        }\r\n        else if (iframe.document) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            iframe.doc = iframe.document; //others?\r\n        }\r\n        return iframe;\r\n    }\r\n    /**\r\n     * Cancel all outstanding queries and remove the frame.\r\n     */\r\n    close() {\r\n        //Mark this iframe as dead, so no new requests are sent.\r\n        this.alive = false;\r\n        if (this.myIFrame) {\r\n            //We have to actually remove all of the html inside this iframe before removing it from the\r\n            //window, or IE will continue loading and executing the script tags we've already added, which\r\n            //can lead to some errors being thrown. Setting textContent seems to be the safest way to do this.\r\n            this.myIFrame.doc.body.textContent = '';\r\n            setTimeout(() => {\r\n                if (this.myIFrame !== null) {\r\n                    document.body.removeChild(this.myIFrame);\r\n                    this.myIFrame = null;\r\n                }\r\n            }, Math.floor(0));\r\n        }\r\n        // Protect from being called recursively.\r\n        const onDisconnect = this.onDisconnect;\r\n        if (onDisconnect) {\r\n            this.onDisconnect = null;\r\n            onDisconnect();\r\n        }\r\n    }\r\n    /**\r\n     * Actually start the long-polling session by adding the first script tag(s) to the iframe.\r\n     * @param id - The ID of this connection\r\n     * @param pw - The password for this connection\r\n     */\r\n    startLongPoll(id, pw) {\r\n        this.myID = id;\r\n        this.myPW = pw;\r\n        this.alive = true;\r\n        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.\r\n        while (this.newRequest_()) { }\r\n    }\r\n    /**\r\n     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\r\n     * too many outstanding requests and we are still alive.\r\n     *\r\n     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\r\n     * needed.\r\n     */\r\n    newRequest_() {\r\n        // We keep one outstanding request open all the time to receive data, but if we need to send data\r\n        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically\r\n        // close the old request.\r\n        if (this.alive &&\r\n            this.sendNewPolls &&\r\n            this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {\r\n            //construct our url\r\n            this.currentSerial++;\r\n            const urlParams = {};\r\n            urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;\r\n            urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;\r\n            urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;\r\n            let theURL = this.urlFn(urlParams);\r\n            //Now add as much data as we can.\r\n            let curDataString = '';\r\n            let i = 0;\r\n            while (this.pendingSegs.length > 0) {\r\n                //first, lets see if the next segment will fit.\r\n                const nextSeg = this.pendingSegs[0];\r\n                if (nextSeg.d.length +\r\n                    SEG_HEADER_SIZE +\r\n                    curDataString.length <=\r\n                    MAX_URL_DATA_SIZE) {\r\n                    //great, the segment will fit. Lets append it.\r\n                    const theSeg = this.pendingSegs.shift();\r\n                    curDataString =\r\n                        curDataString +\r\n                            '&' +\r\n                            FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +\r\n                            i +\r\n                            '=' +\r\n                            theSeg.seg +\r\n                            '&' +\r\n                            FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +\r\n                            i +\r\n                            '=' +\r\n                            theSeg.ts +\r\n                            '&' +\r\n                            FIREBASE_LONGPOLL_DATA_PARAM +\r\n                            i +\r\n                            '=' +\r\n                            theSeg.d;\r\n                    i++;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            theURL = theURL + curDataString;\r\n            this.addLongPollTag_(theURL, this.currentSerial);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Queue a packet for transmission to the server.\r\n     * @param segnum - A sequential id for this packet segment used for reassembly\r\n     * @param totalsegs - The total number of segments in this packet\r\n     * @param data - The data for this segment.\r\n     */\r\n    enqueueSegment(segnum, totalsegs, data) {\r\n        //add this to the queue of segments to send.\r\n        this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });\r\n        //send the data immediately if there isn't already data being transmitted, unless\r\n        //startLongPoll hasn't been called yet.\r\n        if (this.alive) {\r\n            this.newRequest_();\r\n        }\r\n    }\r\n    /**\r\n     * Add a script tag for a regular long-poll request.\r\n     * @param url - The URL of the script tag.\r\n     * @param serial - The serial number of the request.\r\n     */\r\n    addLongPollTag_(url, serial) {\r\n        //remember that we sent this request.\r\n        this.outstandingRequests.add(serial);\r\n        const doNewRequest = () => {\r\n            this.outstandingRequests.delete(serial);\r\n            this.newRequest_();\r\n        };\r\n        // If this request doesn't return on its own accord (by the server sending us some data), we'll\r\n        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.\r\n        const keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));\r\n        const readyStateCB = () => {\r\n            // Request completed.  Cancel the keepalive.\r\n            clearTimeout(keepaliveTimeout);\r\n            // Trigger a new request so we can continue receiving data.\r\n            doNewRequest();\r\n        };\r\n        this.addTag(url, readyStateCB);\r\n    }\r\n    /**\r\n     * Add an arbitrary script tag to the iframe.\r\n     * @param url - The URL for the script tag source.\r\n     * @param loadCB - A callback to be triggered once the script has loaded.\r\n     */\r\n    addTag(url, loadCB) {\r\n        if (isNodeSdk()) {\r\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            this.doNodeLongPoll(url, loadCB);\r\n        }\r\n        else {\r\n            // setTimeout(() => {\r\n            //   try {\r\n            //     // if we're already closed, don't add this poll\r\n            //     if (!this.sendNewPolls) {\r\n            //       return;\r\n            //     }\r\n            //     const newScript = this.myIFrame.doc.createElement('script');\r\n            //     newScript.type = 'text/javascript';\r\n            //     newScript.async = true;\r\n            //     newScript.src = url;\r\n            //     // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            //     newScript.onload = (newScript as any).onreadystatechange =\r\n            //       function () {\r\n            //         // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            //         const rstate = (newScript as any).readyState;\r\n            //         if (!rstate || rstate === 'loaded' || rstate === 'complete') {\r\n            //           // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n            //           newScript.onload = (newScript as any).onreadystatechange = null;\r\n            //           if (newScript.parentNode) {\r\n            //             newScript.parentNode.removeChild(newScript);\r\n            //           }\r\n            //           loadCB();\r\n            //         }\r\n            //       };\r\n            //     newScript.onerror = () => {\r\n            //       log('Long-poll script failed to load: ' + url);\r\n            //       this.sendNewPolls = false;\r\n            //       this.close();\r\n            //     };\r\n            //     this.myIFrame.doc.body.appendChild(newScript);\r\n            //   } catch (e) {\r\n            //     // TODO: we should make this error visible somehow\r\n            //   }\r\n            // }, Math.floor(1));\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=BrowserPollConnection.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/util/dist/index.d.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/RepoInfo.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/stats/StatsCollection.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/stats/StatsManager.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/util.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/realtime/Constants.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/realtime/polling/PacketReceiver.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/realtime/Transport.ts"],"map":"{\"version\":3,\"file\":\"BrowserPollConnection.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/realtime/BrowserPollConnection.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/realtime/BrowserPollConnection.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { RepoInfo } from '../core/RepoInfo';\r\nimport { PacketReceiver } from './polling/PacketReceiver';\r\nimport { Transport } from './Transport';\r\nexport declare const FIREBASE_LONGPOLL_START_PARAM = \"start\";\r\nexport declare const FIREBASE_LONGPOLL_CLOSE_COMMAND = \"close\";\r\nexport declare const FIREBASE_LONGPOLL_COMMAND_CB_NAME = \"pLPCommand\";\r\nexport declare const FIREBASE_LONGPOLL_DATA_CB_NAME = \"pRTLPCB\";\r\nexport declare const FIREBASE_LONGPOLL_ID_PARAM = \"id\";\r\nexport declare const FIREBASE_LONGPOLL_PW_PARAM = \"pw\";\r\nexport declare const FIREBASE_LONGPOLL_SERIAL_PARAM = \"ser\";\r\nexport declare const FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = \"cb\";\r\nexport declare const FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = \"seg\";\r\nexport declare const FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = \"ts\";\r\nexport declare const FIREBASE_LONGPOLL_DATA_PARAM = \"d\";\r\nexport declare const FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM = \"disconn\";\r\nexport declare const FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = \"dframe\";\r\n/**\r\n * This class manages a single long-polling connection.\r\n */\r\nexport declare class BrowserPollConnection implements Transport {\r\n    connId: string;\r\n    repoInfo: RepoInfo;\r\n    private applicationId?;\r\n    private appCheckToken?;\r\n    private authToken?;\r\n    transportSessionId?: string;\r\n    lastSessionId?: string;\r\n    bytesSent: number;\r\n    bytesReceived: number;\r\n    urlFn: (params: object) => string;\r\n    scriptTagHolder: FirebaseIFrameScriptHolder;\r\n    myDisconnFrame: HTMLIFrameElement;\r\n    curSegmentNum: number;\r\n    myPacketOrderer: PacketReceiver;\r\n    id: string;\r\n    password: string;\r\n    private log_;\r\n    private stats_;\r\n    private everConnected_;\r\n    private isClosed_;\r\n    private connectTimeoutTimer_;\r\n    private onDisconnect_;\r\n    /**\r\n     * @param connId An identifier for this connection, used for logging\r\n     * @param repoInfo The info for the endpoint to send data to.\r\n     * @param applicationId The Firebase App ID for this project.\r\n     * @param appCheckToken The AppCheck token for this client.\r\n     * @param authToken The AuthToken to use for this connection.\r\n     * @param transportSessionId Optional transportSessionid if we are\r\n     * reconnecting for an existing transport session\r\n     * @param lastSessionId Optional lastSessionId if the PersistentConnection has\r\n     * already created a connection previously\r\n     */\r\n    constructor(connId: string, repoInfo: RepoInfo, applicationId?: string, appCheckToken?: string, authToken?: string, transportSessionId?: string, lastSessionId?: string);\r\n    /**\r\n     * @param onMessage - Callback when messages arrive\r\n     * @param onDisconnect - Callback with connection lost.\r\n     */\r\n    open(onMessage: (msg: {}) => void, onDisconnect: (a?: boolean) => void): void;\r\n    /**\r\n     * Call this when a handshake has completed successfully and we want to consider the connection established\r\n     */\r\n    start(): void;\r\n    static forceAllow_: boolean;\r\n    /**\r\n     * Forces long polling to be considered as a potential transport\r\n     */\r\n    static forceAllow(): void;\r\n    static forceDisallow_: boolean;\r\n    /**\r\n     * Forces longpolling to not be considered as a potential transport\r\n     */\r\n    static forceDisallow(): void;\r\n    static isAvailable(): boolean;\r\n    /**\r\n     * No-op for polling\r\n     */\r\n    markConnectionHealthy(): void;\r\n    /**\r\n     * Stops polling and cleans up the iframe\r\n     */\r\n    private shutdown_;\r\n    /**\r\n     * Triggered when this transport is closed\r\n     */\r\n    private onClosed_;\r\n    /**\r\n     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server\r\n     * that we've left.\r\n     */\r\n    close(): void;\r\n    /**\r\n     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then\r\n     * broken into chunks (since URLs have a small maximum length).\r\n     * @param data - The JSON data to transmit.\r\n     */\r\n    send(data: {}): void;\r\n    /**\r\n     * This is how we notify the server that we're leaving.\r\n     * We aren't able to send requests with DHTML on a window close event, but we can\r\n     * trigger XHR requests in some browsers (everything but Opera basically).\r\n     */\r\n    addDisconnectPingFrame(id: string, pw: string): void;\r\n    /**\r\n     * Used to track the bytes received by this client\r\n     */\r\n    private incrementIncomingBytes_;\r\n}\r\nexport interface IFrameElement extends HTMLIFrameElement {\r\n    doc: Document;\r\n}\r\n/*********************************************************************************************\r\n * A wrapper around an iframe that is used as a long-polling script holder.\r\n *********************************************************************************************/\r\nexport declare class FirebaseIFrameScriptHolder {\r\n    onDisconnect: () => void;\r\n    urlFn: (a: object) => string;\r\n    outstandingRequests: Set<number>;\r\n    pendingSegs: Array<{\r\n        seg: number;\r\n        ts: number;\r\n        d: unknown;\r\n    }>;\r\n    currentSerial: number;\r\n    sendNewPolls: boolean;\r\n    uniqueCallbackIdentifier: number;\r\n    myIFrame: IFrameElement;\r\n    alive: boolean;\r\n    myID: string;\r\n    myPW: string;\r\n    commandCB: (command: string, ...args: unknown[]) => void;\r\n    onMessageCB: (...args: unknown[]) => void;\r\n    /**\r\n     * @param commandCB - The callback to be called when control commands are recevied from the server.\r\n     * @param onMessageCB - The callback to be triggered when responses arrive from the server.\r\n     * @param onDisconnect - The callback to be triggered when this tag holder is closed\r\n     * @param urlFn - A function that provides the URL of the endpoint to send data to.\r\n     */\r\n    constructor(commandCB: (command: string, ...args: unknown[]) => void, onMessageCB: (...args: unknown[]) => void, onDisconnect: () => void, urlFn: (a: object) => string);\r\n    /**\r\n     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can\r\n     * actually use.\r\n     */\r\n    private static createIFrame_;\r\n    /**\r\n     * Cancel all outstanding queries and remove the frame.\r\n     */\r\n    close(): void;\r\n    /**\r\n     * Actually start the long-polling session by adding the first script tag(s) to the iframe.\r\n     * @param id - The ID of this connection\r\n     * @param pw - The password for this connection\r\n     */\r\n    startLongPoll(id: string, pw: string): void;\r\n    /**\r\n     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't\r\n     * too many outstanding requests and we are still alive.\r\n     *\r\n     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if\r\n     * needed.\r\n     */\r\n    private newRequest_;\r\n    /**\r\n     * Queue a packet for transmission to the server.\r\n     * @param segnum - A sequential id for this packet segment used for reassembly\r\n     * @param totalsegs - The total number of segments in this packet\r\n     * @param data - The data for this segment.\r\n     */\r\n    enqueueSegment(segnum: number, totalsegs: number, data: unknown): void;\r\n    /**\r\n     * Add a script tag for a regular long-poll request.\r\n     * @param url - The URL of the script tag.\r\n     * @param serial - The serial number of the request.\r\n     */\r\n    private addLongPollTag_;\r\n    /**\r\n     * Add an arbitrary script tag to the iframe.\r\n     * @param url - The URL for the script tag source.\r\n     * @param loadCB - A callback to be triggered once the script has loaded.\r\n     */\r\n    addTag(url: string, loadCB: () => void): void;\r\n}\r\n"}}
