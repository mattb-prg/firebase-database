{"code":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { __values } from \"tslib\";\r\nimport { warn } from '../core/util/util';\r\nimport { BrowserPollConnection } from './BrowserPollConnection';\r\nimport { WebSocketConnection } from './WebSocketConnection';\r\n/**\r\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\r\n * lifecycle.\r\n *\r\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\r\n * they are available.\r\n */\r\nvar TransportManager = /** @class */ (function () {\r\n    /**\r\n     * @param repoInfo - Metadata around the namespace we're connecting to\r\n     */\r\n    function TransportManager(repoInfo) {\r\n        this.initTransports_(repoInfo);\r\n    }\r\n    Object.defineProperty(TransportManager, \"ALL_TRANSPORTS\", {\r\n        get: function () {\r\n            return [BrowserPollConnection, WebSocketConnection];\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TransportManager, \"IS_TRANSPORT_INITIALIZED\", {\r\n        /**\r\n         * Returns whether transport has been selected to ensure WebSocketConnection or BrowserPollConnection are not called after\r\n         * TransportManager has already set up transports_\r\n         */\r\n        get: function () {\r\n            return this.globalTransportInitialized_;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    TransportManager.prototype.initTransports_ = function (repoInfo) {\r\n        var e_1, _a;\r\n        var isWebSocketsAvailable = WebSocketConnection && WebSocketConnection['isAvailable']();\r\n        var isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();\r\n        if (repoInfo.webSocketOnly) {\r\n            if (!isWebSocketsAvailable) {\r\n                warn(\"wss:// URL used, but browser isn't known to support websockets.  Trying anyway.\");\r\n            }\r\n            isSkipPollConnection = true;\r\n        }\r\n        if (isSkipPollConnection) {\r\n            this.transports_ = [WebSocketConnection];\r\n        }\r\n        else {\r\n            var transports = (this.transports_ = []);\r\n            try {\r\n                for (var _b = __values(TransportManager.ALL_TRANSPORTS), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var transport = _c.value;\r\n                    if (transport && transport['isAvailable']()) {\r\n                        transports.push(transport);\r\n                    }\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n            TransportManager.globalTransportInitialized_ = true;\r\n        }\r\n    };\r\n    /**\r\n     * @returns The constructor for the initial transport to use\r\n     */\r\n    TransportManager.prototype.initialTransport = function () {\r\n        if (this.transports_.length > 0) {\r\n            return this.transports_[0];\r\n        }\r\n        else {\r\n            throw new Error('No transports available');\r\n        }\r\n    };\r\n    /**\r\n     * @returns The constructor for the next transport, or null\r\n     */\r\n    TransportManager.prototype.upgradeTransport = function () {\r\n        if (this.transports_.length > 1) {\r\n            return this.transports_[1];\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    };\r\n    // Keeps track of whether the TransportManager has already chosen a transport to use\r\n    TransportManager.globalTransportInitialized_ = false;\r\n    return TransportManager;\r\n}());\r\nexport { TransportManager };\r\n//# sourceMappingURL=TransportManager.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/RepoInfo.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/util.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/realtime/BrowserPollConnection.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/realtime/Transport.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/realtime/WebSocketConnection.ts"],"map":"{\"version\":3,\"file\":\"TransportManager.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/realtime/TransportManager.ts\"],\"names\":[],\"mappings\":\"AAAA;;;;;;;;;;;;;;;GAeG;;AAGH,OAAO,EAAE,IAAI,EAAE,MAAM,mBAAmB,CAAC;AAEzC,OAAO,EAAE,qBAAqB,EAAE,MAAM,yBAAyB,CAAC;AAEhE,OAAO,EAAE,mBAAmB,EAAE,MAAM,uBAAuB,CAAC;AAE5D;;;;;;GAMG;AACH;IAkBE;;OAEG;IACH,0BAAY,QAAkB;QAC5B,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;IACjC,CAAC;IAjBD,sBAAW,kCAAc;aAAzB;YACE,OAAO,CAAC,qBAAqB,EAAE,mBAAmB,CAAC,CAAC;QACtD,CAAC;;;OAAA;IAMD,sBAAW,4CAAwB;QAJnC;;;WAGG;aACH;YACE,OAAO,IAAI,CAAC,2BAA2B,CAAC;QAC1C,CAAC;;;OAAA;IASO,0CAAe,GAAvB,UAAwB,QAAkB;;QACxC,IAAM,qBAAqB,GACzB,mBAAmB,IAAI,mBAAmB,CAAC,aAAa,CAAC,EAAE,CAAC;QAC9D,IAAI,oBAAoB,GACtB,qBAAqB,IAAI,CAAC,mBAAmB,CAAC,gBAAgB,EAAE,CAAC;QAEnE,IAAI,QAAQ,CAAC,aAAa,EAAE;YAC1B,IAAI,CAAC,qBAAqB,EAAE;gBAC1B,IAAI,CACF,iFAAiF,CAClF,CAAC;aACH;YAED,oBAAoB,GAAG,IAAI,CAAC;SAC7B;QAED,IAAI,oBAAoB,EAAE;YACxB,IAAI,CAAC,WAAW,GAAG,CAAC,mBAAmB,CAAC,CAAC;SAC1C;aAAM;YACL,IAAM,UAAU,GAAG,CAAC,IAAI,CAAC,WAAW,GAAG,EAA4B,CAAC,CAAC;;gBACrE,KAAwB,IAAA,KAAA,SAAA,gBAAgB,CAAC,cAAc,CAAA,gBAAA,4BAAE;oBAApD,IAAM,SAAS,WAAA;oBAClB,IAAI,SAAS,IAAI,SAAS,CAAC,aAAa,CAAC,EAAE,EAAE;wBAC3C,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;qBAC5B;iBACF;;;;;;;;;YACD,gBAAgB,CAAC,2BAA2B,GAAG,IAAI,CAAC;SACrD;IACH,CAAC;IAED;;OAEG;IACH,2CAAgB,GAAhB;QACE,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;YAC/B,OAAO,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;SAC5B;aAAM;YACL,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;SAC5C;IACH,CAAC;IAED;;OAEG;IACH,2CAAgB,GAAhB;QACE,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE;YAC/B,OAAO,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;SAC5B;aAAM;YACL,OAAO,IAAI,CAAC;SACb;IACH,CAAC;IAvED,oFAAoF;IAC7E,4CAA2B,GAAG,KAAK,CAAC;IAuE7C,uBAAC;CAAA,AA3ED,IA2EC;SA3EY,gBAAgB\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/realtime/TransportManager.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { RepoInfo } from '../core/RepoInfo';\r\nimport { BrowserPollConnection } from './BrowserPollConnection';\r\nimport { TransportConstructor } from './Transport';\r\nimport { WebSocketConnection } from './WebSocketConnection';\r\n/**\r\n * Currently simplistic, this class manages what transport a Connection should use at various stages of its\r\n * lifecycle.\r\n *\r\n * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if\r\n * they are available.\r\n */\r\nexport declare class TransportManager {\r\n    private transports_;\r\n    static globalTransportInitialized_: boolean;\r\n    static get ALL_TRANSPORTS(): (typeof BrowserPollConnection | typeof WebSocketConnection)[];\r\n    /**\r\n     * Returns whether transport has been selected to ensure WebSocketConnection or BrowserPollConnection are not called after\r\n     * TransportManager has already set up transports_\r\n     */\r\n    static get IS_TRANSPORT_INITIALIZED(): boolean;\r\n    /**\r\n     * @param repoInfo - Metadata around the namespace we're connecting to\r\n     */\r\n    constructor(repoInfo: RepoInfo);\r\n    private initTransports_;\r\n    /**\r\n     * @returns The constructor for the initial transport to use\r\n     */\r\n    initialTransport(): TransportConstructor;\r\n    /**\r\n     * @returns The constructor for the next transport, or null\r\n     */\r\n    upgradeTransport(): TransportConstructor | null;\r\n}\r\n"}}
