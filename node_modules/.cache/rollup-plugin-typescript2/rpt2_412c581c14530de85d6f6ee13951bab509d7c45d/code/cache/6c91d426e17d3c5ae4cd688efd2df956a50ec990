{"code":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nimport { assert } from '@firebase/util';\r\nimport { tryParseInt, MAX_NAME, MIN_NAME, INTEGER_32_MIN, INTEGER_32_MAX } from '../util/util';\r\n// Modeled after base64 web-safe chars, but ordered by ASCII.\r\nvar PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';\r\nvar MIN_PUSH_CHAR = '-';\r\nvar MAX_PUSH_CHAR = 'z';\r\nvar MAX_KEY_LEN = 786;\r\n/**\r\n * Fancy ID generator that creates 20-character string identifiers with the\r\n * following properties:\r\n *\r\n * 1. They're based on timestamp so that they sort *after* any existing ids.\r\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\r\n *    collide with other clients' IDs.\r\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\r\n *    that will sort properly).\r\n * 4. They're monotonically increasing. Even if you generate more than one in\r\n *    the same timestamp, the latter ones will sort after the former ones. We do\r\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\r\n *    in the case of a timestamp collision).\r\n */\r\nexport var nextPushId = (function () {\r\n    // Timestamp of last push, used to prevent local collisions if you push twice\r\n    // in one ms.\r\n    var lastPushTime = 0;\r\n    // We generate 72-bits of randomness which get turned into 12 characters and\r\n    // appended to the timestamp to prevent collisions with other clients. We\r\n    // store the last characters we generated because in the event of a collision,\r\n    // we'll use those same characters except \"incremented\" by one.\r\n    var lastRandChars = [];\r\n    return function (now) {\r\n        var duplicateTime = now === lastPushTime;\r\n        lastPushTime = now;\r\n        var i;\r\n        var timeStampChars = new Array(8);\r\n        for (i = 7; i >= 0; i--) {\r\n            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\r\n            // NOTE: Can't use << here because javascript will convert to int and lose\r\n            // the upper bits.\r\n            now = Math.floor(now / 64);\r\n        }\r\n        assert(now === 0, 'Cannot push at time == 0');\r\n        var id = timeStampChars.join('');\r\n        if (!duplicateTime) {\r\n            for (i = 0; i < 12; i++) {\r\n                lastRandChars[i] = Math.floor(Math.random() * 64);\r\n            }\r\n        }\r\n        else {\r\n            // If the timestamp hasn't changed since last push, use the same random\r\n            // number, except incremented by 1.\r\n            for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\r\n                lastRandChars[i] = 0;\r\n            }\r\n            lastRandChars[i]++;\r\n        }\r\n        for (i = 0; i < 12; i++) {\r\n            id += PUSH_CHARS.charAt(lastRandChars[i]);\r\n        }\r\n        assert(id.length === 20, 'nextPushId: Length should be 20.');\r\n        return id;\r\n    };\r\n})();\r\nexport var successor = function (key) {\r\n    if (key === '' + INTEGER_32_MAX) {\r\n        // See https://firebase.google.com/docs/database/web/lists-of-data#data-order\r\n        return MIN_PUSH_CHAR;\r\n    }\r\n    var keyAsInt = tryParseInt(key);\r\n    if (keyAsInt != null) {\r\n        return '' + (keyAsInt + 1);\r\n    }\r\n    var next = new Array(key.length);\r\n    for (var i_1 = 0; i_1 < next.length; i_1++) {\r\n        next[i_1] = key.charAt(i_1);\r\n    }\r\n    if (next.length < MAX_KEY_LEN) {\r\n        next.push(MIN_PUSH_CHAR);\r\n        return next.join('');\r\n    }\r\n    var i = next.length - 1;\r\n    while (i >= 0 && next[i] === MAX_PUSH_CHAR) {\r\n        i--;\r\n    }\r\n    // `successor` was called on the largest possible key, so return the\r\n    // MAX_NAME, which sorts larger than all keys.\r\n    if (i === -1) {\r\n        return MAX_NAME;\r\n    }\r\n    var source = next[i];\r\n    var sourcePlusOne = PUSH_CHARS.charAt(PUSH_CHARS.indexOf(source) + 1);\r\n    next[i] = sourcePlusOne;\r\n    return next.slice(0, i + 1).join('');\r\n};\r\n// `key` is assumed to be non-empty.\r\nexport var predecessor = function (key) {\r\n    if (key === '' + INTEGER_32_MIN) {\r\n        return MIN_NAME;\r\n    }\r\n    var keyAsInt = tryParseInt(key);\r\n    if (keyAsInt != null) {\r\n        return '' + (keyAsInt - 1);\r\n    }\r\n    var next = new Array(key.length);\r\n    for (var i = 0; i < next.length; i++) {\r\n        next[i] = key.charAt(i);\r\n    }\r\n    // If `key` ends in `MIN_PUSH_CHAR`, the largest key lexicographically\r\n    // smaller than `key`, is `key[0:key.length - 1]`. The next key smaller\r\n    // than that, `predecessor(predecessor(key))`, is\r\n    //\r\n    // `key[0:key.length - 2] + (key[key.length - 1] - 1) + \\\r\n    //   { MAX_PUSH_CHAR repeated MAX_KEY_LEN - (key.length - 1) times }\r\n    //\r\n    // analogous to increment/decrement for base-10 integers.\r\n    //\r\n    // This works because lexigographic comparison works character-by-character,\r\n    // using length as a tie-breaker if one key is a prefix of the other.\r\n    if (next[next.length - 1] === MIN_PUSH_CHAR) {\r\n        if (next.length === 1) {\r\n            // See https://firebase.google.com/docs/database/web/lists-of-data#orderbykey\r\n            return '' + INTEGER_32_MAX;\r\n        }\r\n        delete next[next.length - 1];\r\n        return next.join('');\r\n    }\r\n    // Replace the last character with it's immediate predecessor, and\r\n    // fill the suffix of the key with MAX_PUSH_CHAR. This is the\r\n    // lexicographically largest possible key smaller than `key`.\r\n    next[next.length - 1] = PUSH_CHARS.charAt(PUSH_CHARS.indexOf(next[next.length - 1]) - 1);\r\n    return next.join('') + MAX_PUSH_CHAR.repeat(MAX_KEY_LEN - next.length);\r\n};\r\n//# sourceMappingURL=NextPushId.js.map","references":["/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/util/dist/index.d.ts","/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/src/core/util/util.ts"],"map":"{\"version\":3,\"file\":\"NextPushId.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../../src/core/util/NextPushId.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/home/matt/Desktop/Projects/Freelance/Damon Chen/firebase-package/packages/database/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/core/util/NextPushId.d.ts","writeByteOrderMark":false,"text":"/**\r\n * @license\r\n * Copyright 2017 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Fancy ID generator that creates 20-character string identifiers with the\r\n * following properties:\r\n *\r\n * 1. They're based on timestamp so that they sort *after* any existing ids.\r\n * 2. They contain 72-bits of random data after the timestamp so that IDs won't\r\n *    collide with other clients' IDs.\r\n * 3. They sort *lexicographically* (so the timestamp is converted to characters\r\n *    that will sort properly).\r\n * 4. They're monotonically increasing. Even if you generate more than one in\r\n *    the same timestamp, the latter ones will sort after the former ones. We do\r\n *    this by using the previous random bits but \"incrementing\" them by 1 (only\r\n *    in the case of a timestamp collision).\r\n */\r\nexport declare const nextPushId: (now: number) => string;\r\nexport declare const successor: (key: string) => string;\r\nexport declare const predecessor: (key: string) => string;\r\n"}}
